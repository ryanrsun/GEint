#' GE_scoreeq_sim.R
#'
#' Deprecated as of Sep 27, 2016. Designed to work only with scalar Z and M.
#'
#' Here we perform simulation to verify that we have solved for
#' the correct alpha values. 
#' No vector covariates yet, just scalars.
#' Assume all covariates are marginally normal and jointly multivariate normal,
#' with the exception of G, which is generated by thresholding two (pairwise independent) normals.
#' Assume all covariates have variance 1, except for G.
#  Assume all fitted covariates are centered at 0.
#' Assume F=E^2 and W=M^2.
#' 
#' @param num_sims The number of repetitions to run, default is 5000
#' @param num_sub The number of subjects to simulate, default is 2000
#' @param beta_vec A vector of the effect sizes in the true model.
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.
#' @param prob_G Probability that an allele is 1.  Since G has two alleles, E[G]=2*prob_G.
#' @param rho_vec A vector of the covariances in the order:
#' (1) cov_GE (2) cov_GZ (3) cov_EZ (4) cov_GW (5) cov_EW (6) cov_ZW.
#'
#' @keywords simulation
#' @export
#' @examples 
#' library(mvtnorm)
#' rho_vec <- rep(0.3, 6)
#' beta_vec <- runif(6)
#' prob_G <- runif(1, min=0.05, max=0.95)
#' GE_bias_results <- GE_bias_normal_squaredmis(beta_vec, mu_vec, rho_vec)
#' GE_nleqslv(GE_bias_results$beta_vec, GE_bias_results$mu_vec, GE_bias_results$cov_vec,
#' 		GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW,
#' 		GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_vec)
#' GE_scoreeq_sim(beta_vec=beta_vec, prob_G, rho_vec=rho_vec)

scalar_GE_scoreeq_sim <- function(num_sims=5000, num_sub=2000, beta_vec, prob_G, rho_vec)
{
	results <- matrix(data=NA, nrow=num_sims, ncol=6)
	sig_mat <- matrix(data=0, nrow=5, ncol=5)
	
	# Translate the covariances with G into the correct covariances for the continuous
	# variables that will be thresholded to make G.
	# The first two rows of the sig_mat are for G1 and G2, and the next three are E,Z,W.
	threshold <- qnorm(1-prob_G)
	new_GE <- rho_vec[1] / (2*dnorm(threshold))
	new_GZ <- rho_vec[2] / (2*dnorm(threshold))
	new_GW <- rho_vec[4] / (2*dnorm(threshold))
	sig_mat[1,3] = sig_mat[3,1] = sig_mat[2,3] = sig_mat[3,2] = new_GE
	sig_mat[1,4] = sig_mat[4,1] = sig_mat[2,4] = sig_mat[4,2] = new_GZ
	sig_mat[1,5] = sig_mat[5,1] = sig_mat[2,5] = sig_mat[5,2] = new_GW
	sig_mat[3,4] = sig_mat[4,3] = rho_vec[3]
	sig_mat[3,5] = sig_mat[5,3] = rho_vec[5]
	sig_mat[4,5] = sig_mat[5,4] = rho_vec[6]
	diag(sig_mat) <- 1
	
	beta_0 <- beta_vec[1]
	beta_G <- beta_vec[2]
	beta_E <- beta_vec[3]
	beta_I <- beta_vec[4]
	BETA_Z <- beta_vec[5]
	BETA_M <- beta_vec[6]
	
	sim_data <- tryCatch(mvtnorm::rmvnorm(n=num_sub, mean=rep(0,5), sigma=sig_mat),
					warning=function(w) w, error=function(e) e)
	if (class(sim_data)[1] == 'simpleError') {return(-1)}
	
	for(i in 1:num_sims)
	{
		# Sim covariates
		sim_data <- mvtnorm::rmvnorm(n=num_sub, mean=c(rep(0,5)), sigma=sig_mat)		
		snp1 <- as.numeric(sim_data[,1]>threshold)
		snp2 <- as.numeric(sim_data[,2]>threshold)
		G <- snp1 + snp2 - 2*prob_G
		E <- sim_data[,3]
		Z <- sim_data[,4]
		W <- sim_data[,5]

		# Sim outcome
		d_right <- cbind(1, G, E^2, G*E^2, Z, W^2)
		d_wrong <- cbind(1, G, E, G*E, Z, W)
		Y <- d_right %*% beta_vec + rnorm(num_sub)
		
		# Solve for beta_hat
		b_hat <- solve(t(d_wrong) %*% d_wrong) %*% t(d_wrong) %*% Y
		results[i,] <- b_hat
		
		# Checkpoint
		if (i%%1000 == 0) {cat(i, "done\n")}
	}
	colnames(results) <- c('alpha_0', 'alpha_G', 'alpha_E', 'alpha_I', 'ALPHA_Z', 'ALPHA_W')
	sim_alpha <- apply(results, 2, mean)
	
	return(sim_alpha)
}

