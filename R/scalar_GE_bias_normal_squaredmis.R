#' GE_bias_normal_squaredmis
#'
#' Deprecated version as of Sep 27, 2016.  Designed to work only with scalar inputs for Z and W/M.
#'
#' A function to calculate the bias in testing for GxE interaction.
#' Here we make the following assumptions:
#' (1) All covariates (besides E) are marginally normally distributed with 
#' unit variance.  In addition, E,Z,W have mean 0.
#' (2) G is generated by means of thresholding two independent normal RVs (jointly generated
#' with the other covariates) and is centered to have mean 0.
#' (3) The misspecification is of the form f(E)=h(E)=E^2, and M=W^2.
#' (4) All covariate terms exist and are scalars.
#' 
#' @param beta_vec A vector of the effect sizes in the true model.
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.
#' @param rho_vec A vector of the 10 pairwise covariances between the
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ
#' (4) cov_GW (5) cov_EW (6) cov_ZW.
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has
#' two alleles, the expectation of G is 2*prob_G.
#' 
#' @keywords bias normal squared_misspecification
#' @export
#' @examples 
#' scalar_GE_bias_normal_squaredmis( beta_vec=runif(n=6, min=0, max=1), rho_vec=rep(0.3,1), prob_G=0.3)

scalar_GE_bias_normal_squaredmis <- function(beta_vec, rho_vec, prob_G)
{
  # First, make sure we got good inputs
  if (!is.numeric(beta_vec) | !is.numeric(rho_vec) | !is.numeric(prob_G))
  {
    stop('Nonnumeric inputs!')
  }
  
  if (length(beta_vec) != 6 | length(rho_vec) != 6)
  {
    stop('Input vectors not the right size!')
  }
  
  # Translate inputs directly
  rho_GE <- rho_vec[1]
  rho_GZ <- rho_vec[2]
  rho_EZ <- rho_vec[3]
  rho_GW <- rho_vec[4]
  rho_EW <- rho_vec[5]
  rho_ZW <- rho_vec[6]
  
  beta_0 <- beta_vec[1]
  beta_G <- beta_vec[2]
  beta_E <- beta_vec[3]
  beta_I <- beta_vec[4]
  BETA_Z <- beta_vec[5]  	
  BETA_M <- beta_vec[6]
  
  # Calculated values for generation of data (given to rmvnorm), 
  # different from inputs for terms involving G
  w <- qnorm(1-prob_G)					# Threshold for generating G
  r_GE <- rho_GE / (2*dnorm(w))			# See gen_cor_bin_normal for explanation, for generating covariates jointly
  r_GZ <- rho_GZ / (2*dnorm(w))
  r_GW <- rho_GW / (2*dnorm(w))
  
  # Now make sure we can actually generate data with this structure
  temp_sig <- matrix(data=c(1, 0, r_GE, r_GZ, r_GW,
								0, 1, r_GE, r_GZ, r_GW,
								r_GE, r_GE, 1, rho_EZ, rho_EW,
								r_GZ, r_GZ, rho_EZ, 1, rho_ZW,
								r_GW, r_GW, rho_EW, rho_ZW, 1), nrow=5)
  test_data <- tryCatch(rmvnorm(n=1, sigma=temp_sig), 
  				warning=function(w) w, error=function(e) e)
  if (class(test_data)[1] != 'matrix') {stop('You specified an impossible covariance matrix!')}
								
  # Obvious and by assumptions
  MU_Z <- 0 		# Some obvious ones
  MU_M <- 1		
  MU_W <- 0			
  mu_f <- 1
  mu_h <- 1
  
  # Done translating inputs
  # Now calculate other necessary terms that have 
  # been determined by out assumptions + inputs
  
  ########################
  # Covariances
  mu_GE <- rho_GE
  mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G
  mu_Gh <- mu_Gf
  mu_GG <- 2*prob_G*(1-prob_G)
  MU_GZ <- rho_GZ  	# Vector
  MU_GW <- rho_GW		# Vector
  MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation
  MU_EM <- 	0				# Vector, in particular because third moment of W is 0
  MU_EZ <- rho_EZ			# Vector
  MU_EW <- rho_EW			# Vector
  mu_EE <- 1
  mu_Ef <- 0
  MU_fZ <- 	0	# Vector
  MU_fW <- 	0		# Vector
  
  ########################
  # Matrix covariances
  MU_ZW <- rho_ZW		# Matrix	 
  MU_ZM <- 0 		# Matrix
  MU_WM <- 0 		# Matrix
  MU_ZZ <- 1 		# Matrix
  MU_WW <- 1 		# Matrix
  
  
  ########################
  # Higher order moments
  # We need as intermediate quantities E[G_1E], E[G_1E^2], E[G_1E^3], E[G_1G_2E], E[G_1G_2E^2], E[G1EZ], 
  # E[G1EW], E[G1EW^2], E[G1WE^2], E[G1ZE^2], E[G1G2E^2]
  mu_G1_E <- r_GE*dnorm(w)
  mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)
  mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)
  
  # E[G1G2E] requires numerical integration
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)
  f_G1_G2_E <- function(x,w,r_GE) {
  	x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)
  }
  mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]
  
  # E[G1G2E^2] requires numerical integration
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)
  f_G1_G2_EE <- function(x,w,r_GE) {
  	x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)
  }
  mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]
  
  # E[G1G2E^3] requires numerical integration
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)
  f_G1_G2_EEE <- function(x,w,r_GE) {
  	x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)
  }
  mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]
  
  # E[G1EZ] requires numerical integration
  f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {
  	( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * 
  		(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)
  }
  mu_G1_E_Z <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ, r_GE=r_GE, r_GZ=r_GZ)$Q
  
  # E[G1EW] requires numerical integration
  f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {
  	( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * 
  		(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)
  }
  mu_G1_E_W <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW, r_GE=r_GE, r_GW=r_GW)$Q

  # E[G1EW^2] requires numerical integration
  f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {
  	( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / 
  		sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)
  }
  mu_G1_E_WW <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW, r_EW=rho_EW)$Q
  
  # E[G1WE^2] requires numerical integration
  f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {
  	( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / 
  		sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)
  }
  mu_G1_W_EE <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW, r_EW=rho_EW)$Q
  
  # E[G1ZE^2] requires numerical integration
  f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {
  	( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / 
  		sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)
  }
  mu_G1_Z_EE <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ, r_EZ=rho_EZ)$Q

  
  # See gen_cor_bin_normal to see how to do these
  mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E
  mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE
  mu_GEE <- mu_Gf
  mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))
  mu_GEh <- mu_GEf

  # See gen_cor_bin_normal to see how to do these (vectors)
  MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector
  MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW		# Vector
  MU_GEM <-	2*mu_G1_E_WW				# Vector
  MU_GhW <- 2*mu_G1_W_EE
  MU_GhZ <- 2*mu_G1_Z_EE
  
  mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE
  mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE
  mu_GGEh <- mu_GGEf
  
  
  ########################
  # Some shortcut quantities
  A <- (mu_GE * MU_GZ / mu_GG - MU_EZ) / (mu_EE - mu_GE^2/mu_GG)
  B <- (mu_GE * MU_GW / mu_GG - MU_EW) / (mu_EE - mu_GE^2/mu_GG)
  
  O <- MU_Z%*%t(MU_Z) + MU_GZ%*%t(MU_GZ)/mu_GG - MU_ZZ - A %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG)
  
  C <- (B %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG) - MU_W%*%t(MU_Z) - MU_GW%*%t(MU_GZ)/mu_GG + MU_ZW) %*% solve(O)
  
  Q <- MU_W%*%t(MU_W) + MU_GW%*%t(MU_GW)/mu_GG - MU_WW + B %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + 
    C %*% ( MU_Z%*%t(MU_W) + t(MU_GZ)%*%t(MU_GW)/mu_GG - MU_ZW + A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) )
  
  D <- (mu_GE * mu_GGE / mu_GG - mu_GEE) / (mu_EE - mu_GE^2 / mu_GG)
  E <- t(MU_GEZ - MU_Z*mu_GE - MU_GZ*mu_GGE/mu_GG + D*(MU_EZ - MU_GZ*mu_GE/mu_GG)) %*% solve(O)
  EFF <- ( t(MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + D*(MU_GW * mu_GE / mu_GG - MU_EW)) + 
             E %*% (A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) ) %*% solve(Q)
  
  
  # Solve for \alpha_I
  alpha_I_num <- beta_E * (-mu_f*mu_GE - mu_Gf*mu_GGE/mu_GG + mu_GEf + D * (mu_Ef - mu_Gf*mu_GE/mu_GG)) +
    beta_E * E %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + 
    beta_I * (-mu_Gf*mu_GE - mu_GGh*mu_GGE/mu_GG + mu_GGEh + D * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + 
    beta_I * E %*% (-mu_Gh*MU_Z - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + 
    t(MU_GEM - MU_M*mu_GE - MU_GM*mu_GGE/mu_GG + D * (MU_EM - MU_GM*mu_GE/mu_GG)) %*% BETA_M + 
    E %*% (A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M - 
    beta_E * EFF %*% (-mu_f*MU_W - MU_GW*mu_Gf/mu_GG + MU_fW + B %*% (mu_GEf - mu_GGh*mu_GE/mu_GG)) - 
    beta_E * EFF %*% C %*% (-mu_f*MU_Z - mu_Gf*MU_GZ/mu_GG + MU_fZ + A %*% (mu_Ef - mu_Gf*mu_GE/mu_GG)) - 
    beta_I * EFF %*% (-mu_Gh*MU_W - MU_GW*mu_GGh/mu_GG + MU_GhW + B %*% (mu_GEh - mu_GGh*mu_GE/mu_GG)) -
    beta_I * EFF %*% C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A %*% (mu_GEh - mu_GGh*mu_GE/mu_GG)) - 
    EFF %*% ( -MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM + B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) ) %*% BETA_M - 
    EFF %*% C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M
  
  alpha_I_denom <- EFF %*% ( MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) +
    EFF %*% C %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - 
    ( mu_GE^2 + mu_GGE^2/mu_GG - mu_GGEE + D * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - 
    E %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) )
  
  alpha_I <- alpha_I_num / alpha_I_denom
  
  R <- beta_E * (-MU_W*mu_f - MU_GW*mu_Gf/mu_GG + MU_fW + B * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + 
    beta_E * C %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A %*% (mu_Ef - mu_Gf*mu_GE/mu_GG)) + 
    beta_I * (-MU_W*mu_Gh - MU_GW*mu_GGh/mu_GG + MU_GhW + B * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + 
    beta_I * C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + 
    ( B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM) %*% BETA_M + 
    C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + 
    alpha_I * (MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + 
    alpha_I * C * (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A*(mu_GGE*mu_GE/mu_GG - mu_GEE))
  
  ALPHA_W <- - solve(Q) %*% R
  
  P <- beta_E * (-MU_Z*mu_f - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + 
    beta_I * (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + 
    alpha_I * (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + 
    ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + 
    ( A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) %*% ALPHA_W
  
  Bz_Az <- solve(O) %*% P
  ALPHA_Z <- BETA_Z - solve(O) %*% P
  
  alpha_E <- ( beta_E * (mu_Ef - mu_Gf*mu_GE/mu_GG) + beta_I * (mu_GEh - mu_GGh*mu_GE/mu_GG) +  
                 alpha_I * (mu_GGE*mu_GE/mu_GG - mu_GEE) + t(MU_EZ - MU_GZ*mu_GE/mu_GG) %*% Bz_Az + 
                 t(MU_EM - MU_GM*mu_GE/mu_GG) %*% BETA_M + t(MU_GW*mu_GE/mu_GG - MU_EW) %*% ALPHA_W ) /
    (mu_EE - mu_GE^2/mu_GG)
  
  Bg_Ag <- ( alpha_E*mu_GE - beta_E*mu_Gf + alpha_I*mu_GGE - beta_I*mu_GGh - t(MU_GZ) %*% Bz_Az + 
               t(MU_GW) %*% ALPHA_W - t(MU_GM) %*% BETA_M ) / mu_GG
  alpha_G <- beta_G - Bg_Ag
  
  
  alpha_0 <- beta_0 + beta_E*mu_f + beta_I*mu_Gh - alpha_I*mu_GE + t(MU_Z) %*% Bz_Az +
    t(MU_M) %*% BETA_M - t(MU_W) %*% ALPHA_W
  
  # Return 
  return(list(alpha_vec=c(alpha_0, alpha_G, alpha_E, alpha_I, ALPHA_Z, ALPHA_W),
              beta_vec = c(beta_0, beta_G, beta_E, beta_I, BETA_Z, BETA_M),
              mu_vec = c(mu_f, mu_h, MU_M),
              cov_vec = c(mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,
              mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW),
              MU_ZZ=MU_ZZ, MU_ZM=MU_ZM, MU_ZW=MU_ZW, MU_WM=MU_WM, MU_WW=MU_WW,
              HOM_vec = c(mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,
              MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)))
}