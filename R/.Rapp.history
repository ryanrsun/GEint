r_GE
rho_list
if (length(beta_vec) != 6 | length(rho_list) != 6 | class(beta_vec) != 'list' | class(rho_list) != 'list')#
  	{#
  	  stop('Input vectors not the right size!')#
  	}#
#
	# How long are these vectors?  Remember that W is the same length as M by assumption.#
  	num_Z <- length(beta_vec[[5]])#
  	num_W <- length(beta_vec[[6]])#
  	num_rho <- 2*(num_Z+num_W) + num_Z*num_W + 1#
  	# Make sure we have compatible lengths for rho_list#
    if (length(rho_list[[2]]) != num_Z | length(rho_list[[3]]) != num_Z | length(rho_list[[4]]) != num_W#
   			| length(rho_list[[5]]) != num_W | length(rho_list[[6]]) != num_Z*num_W) {#
   		stop('Incompatible number of elements in beta/rho_list')#
   	}#
   	# Fill in our covariances.#
   	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
   	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]
rho_GE
#################################################################
    # Build our covariance matrix in steps.#
    # The 3x3 in the top left is always the same to build, vectors or not.#
    w <- qnorm(1-prob_G)					# Threshold for generating G#
    r_GE <- rho_GE / (2*dnorm(w))	#
    sig_mat_GE <- matrix(data=c(1, 0, r_GE, 0, 1, r_GE, r_GE, r_GE, 1), nrow=3)
prob_G
w
r_GE
surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_vec[[5]])#
  	num_W <- length(beta_vec[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	sig_mat <- GE_translate_inputs(beta_vec=beta_vec, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)
# Generate test data#
	test_data <- rmvnorm(n=num_sub, sigma=sig_mat)#
	# Get the individual components#
  	G1 <- as.numeric(test_data[,1] > w)#
  	G2 <- as.numeric(test_data[,2] > w)#
  	G <- G1 + G2 - 2*prob_G#
	E <- test_data[,3]#
	Z <- as.matrix(test_data[,4:(3+num_Z)])#
	W <- as.matrix(test_data[,(4+num_Z):(3+num_Z+num_W)])#
  	# Start testing with calculated G covariances#
  	temp_test <- rho_GE - cov(G,E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with rho_GE')}
rho_GE
cov(G,E)
for (i in 1:num_Z)#
  	{#
  		temp_test <- rho_GZ[i] - cov(G,Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with rho_GZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- rho_GW[i] - cov(G,W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with rho_GW')}#
  	}#
  	 #########################
 	 # More covariances#
  	 mu_GE <- rho_GE#
 	 mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
 	 mu_Gh <- mu_Gf#
 	 mu_GG <- 2*prob_G*(1-prob_G)#
 	 MU_GZ <- rho_GZ  	# Vector#
 	 MU_GW <- rho_GW		# Vector#
 	 MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
 	 MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
 	 MU_EZ <- rho_EZ			# Vector#
 	 MU_EW <- rho_EW			# Vector#
 	 mu_EE <- 1#
 	 mu_Ef <- 0#
 	 MU_fZ <- 	rep(0, num_Z)	# Vector#
 	 MU_fW <- 	rep(0, num_W)		# Vector
# Test the above#
  	temp_test <- mu_GE - mean(G*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GE')}#
  	temp_test <- mu_Gf - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_Gf')}#
  	temp_test <- mu_Gh - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_Gh')}#
  	temp_test <- mu_GG - mean(G*G)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GG')}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_GZ[i] - mean(G*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GZ')}#
  	}
MU_GZ
temp_test
for (i in 1:num_W)#
  	{#
  		temp_test <- MU_GW[i] - mean(G*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GW')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_GM[i]- mean(G*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GM')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EM[i] - mean(E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EM')}#
  	}
for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EM[i] - mean(E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EM')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EZ[i] - mean(E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EZ')}#
  	}
for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EM[i] - mean(E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EM')}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_EZ[i] - mean(E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EW[i] - mean(E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EW')}#
  	}
for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EW[i] - mean(E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EW')}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_fZ[i] - mean(E*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_fZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_fW[i] - mean(E*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_fW')}#
  	}
#########################
 	# Matrix covariances#
 	MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  	MU_WZ <- t(MU_ZW)	 #
 	MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
 	MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  	MU_ZZ <- sig_mat_ZZ 		# Matrix#
  	MU_WW <- sig_mat_WW		# Matrix#
  	# Check them#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZW[i,j] - mean(Z[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZW')}#
  		}#
  	}
GE_translate_inputs <- function(beta_vec, rho_list, prob_G, cov_Z=NULL, cov_W=NULL)#
{#
	# First, make sure we got good inputs#
  	if (length(beta_vec) != 6 | length(rho_list) != 6 | class(beta_vec) != 'list' | class(rho_list) != 'list')#
  	{#
  	  stop('Input vectors not the right size!')#
  	}#
#
	# How long are these vectors?  Remember that W is the same length as M by assumption.#
  	num_Z <- length(beta_vec[[5]])#
  	num_W <- length(beta_vec[[6]])#
  	num_rho <- 2*(num_Z+num_W) + num_Z*num_W + 1#
  	# Make sure we have compatible lengths for rho_list#
    if (length(rho_list[[2]]) != num_Z | length(rho_list[[3]]) != num_Z | length(rho_list[[4]]) != num_W#
   			| length(rho_list[[5]]) != num_W | length(rho_list[[6]]) != num_Z*num_W) {#
   		stop('Incompatible number of elements in beta/rho_list')#
   	}#
   	# Fill in our covariances.#
   	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
   	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
   	#################################################################
    # Build our covariance matrix in steps.#
    # The 3x3 in the top left is always the same to build, vectors or not.#
    w <- qnorm(1-prob_G)					# Threshold for generating G#
    r_GE <- rho_GE / (2*dnorm(w))	#
    sig_mat_GE <- matrix(data=c(1, 0, r_GE, 0, 1, r_GE, r_GE, r_GE, 1), nrow=3) #
    # Build the p*3 matrix that describes Z with G1,G2,E#
    sig_mat_Z_column <- matrix(data=NA, nrow=num_Z, ncol=3)#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    for (i in 1:num_Z) {#
    	sig_mat_Z_column[i,] <- c(r_GZ[i], r_GZ[i], rho_EZ[i])#
    }#
    # Build the q*3 matrix that describes W with G1,G2,E#
    sig_mat_W_column <- matrix(data=NA, nrow=num_W, ncol=3)#
    r_GW <- rho_GW / (2*dnorm(w))#
    for (i in 1:num_W) {#
    	sig_mat_W_column[i,] <- c(r_GW[i], r_GW[i], rho_EW[i])#
    }#
    # Build the p*q matrix that describes Z with W#
    sig_mat_Z_W <- matrix(data=NA, nrow=num_Z, ncol=num_W)#
    for (i in 1:num_Z) {#
    	start_ind <- (i-1)*num_W+1#
    	end_ind <- i*num_W#
    	sig_mat_Z_W[i,] <- rho_ZW[start_ind:end_ind]#
    }#
    # If Z or W vectorized, build the ZZ and WW covariance matrices too#
    if (num_Z > 1) {#
    	sig_mat_ZZ <- matrix(data=0, nrow=num_Z, ncol=num_Z)#
    	sig_mat_ZZ[upper.tri(sig_mat_ZZ)] <- cov_Z#
    	sig_mat_ZZ <- sig_mat_ZZ + t(sig_mat_ZZ)#
    	diag(sig_mat_ZZ) <- 1#
    } else {#
    	sig_mat_ZZ <- matrix(data=1, nrow=1, ncol=1)#
    }#
    if (num_W > 1) {#
    	sig_mat_WW <- matrix(data=0, nrow=num_W, ncol=num_W)#
    	sig_mat_WW[upper.tri(sig_mat_WW)] <- cov_W#
    	sig_mat_WW <- sig_mat_WW + t(sig_mat_WW)#
    	diag(sig_mat_WW) <- 1#
    } else {#
    	sig_mat_WW <- matrix(data=1, nrow=1, ncol=1)#
    }#
    # Now put it all together#
    sig_mat_total <- matrix(data=NA, nrow=(3+num_Z+num_W), ncol=(3+num_Z+num_W))#
    sig_mat_total[1:3, 1:3] <- sig_mat_GE#
    sig_mat_total[4:(3+num_Z), 1:3] <- sig_mat_Z_column#
    sig_mat_total[1:3, 4:(3+num_Z)] <- t(sig_mat_Z_column)#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 1:3] <- sig_mat_W_column#
    sig_mat_total[1:3, (4+num_Z):(3+num_Z+num_W)] <- t(sig_mat_W_column)#
    sig_mat_total[4:(3+num_Z), 4:(3+num_Z)] <- sig_mat_ZZ#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_WW#
    sig_mat_total[4:(3+num_Z), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_Z_W#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 4:(3+num_Z)] <- t(sig_mat_Z_W)#
    if (!isSymmetric(sig_mat_total)) {stop("Problem building covariance matrix!")}#
    # Now make sure we can actually generate data with this structure#
    test_data <- tryCatch(rmvnorm(n=1, sigma=sig_mat_total), #
    				warning=function(w) w, error=function(e) e)#
    if (class(test_data)[1] != 'matrix') {stop('You specified an impossible covariance matrix!')}#
    return(list(sig_mat_total=sig_mat_total, sig_mat_ZZ=sig_mat_ZZ, sig_mat_WW=sig_mat_WW))#
}
# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_vec=beta_vec, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	# Generate test data
sig_mat_ZZ
# Matrix covariances#
 	MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  	MU_WZ <- t(MU_ZW)	 #
 	MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
 	MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  	MU_ZZ <- sig_mat_ZZ 		# Matrix#
  	MU_WW <- sig_mat_WW		# Matrix#
  	# Check them#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZW[i,j] - mean(Z[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZW')}#
  		}#
  	}
for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZM[i,j] - mean(Z[,i]*W[,j]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZM')}#
  		}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_WM[i,j] - mean(W[,i]*W[,j]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_WM')}#
  		}#
  	}	#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_Z)#
  		{#
  			temp_test <- MU_ZZ[i,j] - mean(Z[,i]*Z[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZZ')}#
  		}#
  	}
for (i in 1:num_W)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_WW[i,j] - mean(W[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_WM')}#
  		}#
  	}	#
    #########################
 	# Higher order moments, intermediate quantities#
  	mu_G1_E <- r_GE*dnorm(w)#
  	mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  	mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)
temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_E <- function(x,w,r_GE) {#
  		x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_EE <- function(x,w,r_GE) {#
  		x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_EEE <- function(x,w,r_GE) {#
  		x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	# Higher order moments, see gen_cor_bin_normal to see how to do these#
  	mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  	mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  	mu_GEE <- mu_Gf#
  	mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  	mu_GEh <- mu_GEf#
  	mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  	mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  	mu_GGEh <- mu_GGEf
##############  	#
  	# Check	#
  	temp_test <- mu_G1_E - mean(G1*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E')}#
  	temp_test <- mu_G1_EE - mean(G1*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_EE')}#
  	temp_test <- mu_G1_EEE - mean(G1*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_EEE')}#
  	temp_test <- mu_G1_G2_E - mean(G1*G2*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_E')}#
  	temp_test <- mu_G1_G2_EE - mean(G1*G2*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_EE')}#
  	temp_test <- mu_G1_G2_EEE - mean(G1*G2*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_EEE')}#
#
  	temp_test <- mu_GGE - mean(G*G*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GGE')}#
  	temp_test <- mu_GGh - mean(G*G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GGj')}#
  	temp_test <- mu_GEE - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEE')}#
  	temp_test <- mu_GEf - mean(G*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEf')}#
  	temp_test <- mu_GEh - mean(G*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEh')}
temp_test
mu_GEh
mean(G*E*E*E)
###############
  	# Harder intermediate quantities involving Z and W#
  	f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  		( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  			(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  	}#
  	mu_G1_E_Z <- rep(NA, num_Z)#
  	for (i in 1:num_Z) {#
  		mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  		temp_test <- mu_G1_E_Z[i] - mean(G1*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_Z')}#
  	}#
  	mu_G1_E_W <- rep(NA, num_W)#
  	f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  		( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  			(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  		temp_test <- mu_G1_E_W[i] - mean(G1*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_W')}#
	}
mu_G1_E_WW <- rep(NA, num_W)#
  	f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  			sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_E_WW[i] - mean(G1*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_WW')}#
  	}#
    mu_G1_W_EE <- rep(NA, num_E)#
  	f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_E_WW[i] - mean(G1*W[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_W_EE')}#
  	}#
#
    mu_G1_Z_EE  <- rep(NA, num_Z)#
  	f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  		( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}	#
  	for (i in 1:num_Z) {#
  		mu_G1_Z_EE <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ, r_EZ=rho_EZ)$Q#
  		temp_test <- mu_G1_Z_EE[i] - mean(G1*Z[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_Z_EE')}#
 	}
mu_G1_E_WW <- rep(NA, num_W)#
  	f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  			sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_E_WW[i] - mean(G1*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_WW')}#
  	}#
    mu_G1_W_EE <- rep(NA, num_W)#
  	f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_E_WW[i] - mean(G1*W[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_W_EE')}#
  	}#
#
    mu_G1_Z_EE  <- rep(NA, num_Z)#
  	f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  		( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}	#
  	for (i in 1:num_Z) {#
  		mu_G1_Z_EE <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ, r_EZ=rho_EZ)$Q#
  		temp_test <- mu_G1_Z_EE[i] - mean(G1*Z[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_Z_EE')}#
 	}
mu_G1_W_EE <- rep(NA, num_W)#
  	f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_W_EE[i] - mean(G1*W[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_W_EE')}#
  	}
mu_G1_Z_EE  <- rep(NA, num_Z)#
  	f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  		( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}	#
  	for (i in 1:num_Z) {#
  		mu_G1_Z_EE <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ, r_EZ=rho_EZ)$Q#
  		temp_test <- mu_G1_Z_EE[i] - mean(G1*Z[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_Z_EE')}#
 	}
warnings()
mu_G1_Z_EE  <- rep(NA, num_Z)#
  	f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  		( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}	#
  	for (i in 1:num_Z) {#
  		mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ, r_EZ=rho_EZ)$Q#
  		temp_test <- mu_G1_Z_EE[i] - mean(G1*Z[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_Z_EE')}#
 	}
warnings()
mu_G1_Z_EE  <- rep(NA, num_Z)#
  	f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  		( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}	#
  	for (i in 1:num_Z) {#
  		mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  		temp_test <- mu_G1_Z_EE[i] - mean(G1*Z[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_Z_EE')}#
 	}
###############
  	# Check higher orders with Z and W#
  	MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  	MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW		# Vector#
  	MU_GEM <-	2*mu_G1_E_WW				# Vector#
  	MU_GhW <- 2*mu_G1_W_EE#
  	MU_GhZ <- 2*mu_G1_Z_EE#
  	# Test#
 	for (i in 1:num_Z) { 	#
  		temp_test <- MU_GEZ[i] - mean(G*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEZ')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GEW[i] - mean(G*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEW')}#
  	}
for (i in 1:num_W) {#
  		temp_test <- MU_GEM[i] - mean(G*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEM')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GhW[i] - mean(G*E*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GhW')}#
  	}#
  	for (i in 1:num_Z) {#
  		temp_test <- MU_GhZ[i] - mean(G*E*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GhZ')}#
	}
tmep_test
temp_test
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_vec <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
}
rho_list
beta_list
beta_vec
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
}
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
#' GE_test_moment_calcs.R#
#'#
#' An internal test function to ensure the higher order moments (covariances)#
#' calculated in GE_bias_normal_squaredmis.R are correct.#
#'#
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.  If Z and/or W include multiple covariates, then#
#' terms like cov_GZ should be a vector.  #
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector. If Z or M are vectors, then cov_ZW should be a vector in the order#
#' (cov(Z_1,W_1),cov(Z_1,W_2),...,cov(Z_1,W_q),cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is #
#' a vector of length p and W is a vector of length q.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#' @param num_sum Number of subjects to do the simulation with.#
#' @param test_threshold How much margin for error on tests?#
#'#
#' @keywords validation#
#' @export#
#' @examples #
#' test_moment_calcs(beta_list=runif(n=6, min=0, max=1), rho_list=rep(0.3,1), prob_G=0.3)#
#
GE_test_moments_calcs <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL, num_sub=1000000, test_threshold=0.01)#
{#
	# Need survival function#
  	surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_list=beta_list, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	# Generate test data#
	test_data <- rmvnorm(n=num_sub, sigma=sig_mat)#
	# Get the individual components#
  	G1 <- as.numeric(test_data[,1] > w)#
  	G2 <- as.numeric(test_data[,2] > w)#
  	G <- G1 + G2 - 2*prob_G#
	E <- test_data[,3]#
	Z <- as.matrix(test_data[,4:(3+num_Z)])#
	W <- as.matrix(test_data[,(4+num_Z):(3+num_Z+num_W)])#
  	# Start testing with calculated G covariances#
  	temp_test <- rho_GE - cov(G,E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with rho_GE')}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- rho_GZ[i] - cov(G,Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with rho_GZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- rho_GW[i] - cov(G,W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with rho_GW')}#
  	}#
  	 #########################
 	 # More covariances#
  	 mu_GE <- rho_GE#
 	 mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
 	 mu_Gh <- mu_Gf#
 	 mu_GG <- 2*prob_G*(1-prob_G)#
 	 MU_GZ <- rho_GZ  	# Vector#
 	 MU_GW <- rho_GW		# Vector#
 	 MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
 	 MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
 	 MU_EZ <- rho_EZ			# Vector#
 	 MU_EW <- rho_EW			# Vector#
 	 mu_EE <- 1#
 	 mu_Ef <- 0#
 	 MU_fZ <- 	rep(0, num_Z)	# Vector#
 	 MU_fW <- 	rep(0, num_W)		# Vector#
 	# Test the above#
  	temp_test <- mu_GE - mean(G*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GE')}#
  	temp_test <- mu_Gf - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_Gf')}#
  	temp_test <- mu_Gh - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_Gh')}#
  	temp_test <- mu_GG - mean(G*G)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GG')}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_GZ[i] - mean(G*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_GW[i] - mean(G*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GW')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_GM[i]- mean(G*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GM')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EM[i] - mean(E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EM')}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_EZ[i] - mean(E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EW[i] - mean(E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EW')}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_fZ[i] - mean(E*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_fZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_fW[i] - mean(E*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_fW')}#
  	}#
   	#########################
 	# Matrix covariances#
 	MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  	MU_WZ <- t(MU_ZW)	 #
 	MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
 	MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  	MU_ZZ <- sig_mat_ZZ 		# Matrix#
  	MU_WW <- sig_mat_WW		# Matrix#
  	# Check them#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZW[i,j] - mean(Z[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZW')}#
  		}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZM[i,j] - mean(Z[,i]*W[,j]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZM')}#
  		}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_WM[i,j] - mean(W[,i]*W[,j]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_WM')}#
  		}#
  	}	#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_Z)#
  		{#
  			temp_test <- MU_ZZ[i,j] - mean(Z[,i]*Z[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZZ')}#
  		}#
  	}	#
  	for (i in 1:num_W)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_WW[i,j] - mean(W[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_WM')}#
  		}#
  	}	#
    #########################
 	# Higher order moments, intermediate quantities#
  	mu_G1_E <- r_GE*dnorm(w)#
  	mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  	mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_E <- function(x,w,r_GE) {#
  		x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_EE <- function(x,w,r_GE) {#
  		x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_EEE <- function(x,w,r_GE) {#
  		x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	# Higher order moments, see gen_cor_bin_normal to see how to do these#
  	mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  	mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  	mu_GEE <- mu_Gf#
  	mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  	mu_GEh <- mu_GEf#
  	mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  	mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  	mu_GGEh <- mu_GGEf#
 	##############  	#
  	# Check	#
  	temp_test <- mu_G1_E - mean(G1*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E')}#
  	temp_test <- mu_G1_EE - mean(G1*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_EE')}#
  	temp_test <- mu_G1_EEE - mean(G1*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_EEE')}#
  	temp_test <- mu_G1_G2_E - mean(G1*G2*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_E')}#
  	temp_test <- mu_G1_G2_EE - mean(G1*G2*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_EE')}#
  	temp_test <- mu_G1_G2_EEE - mean(G1*G2*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_EEE')}#
#
  	temp_test <- mu_GGE - mean(G*G*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GGE')}#
  	temp_test <- mu_GGh - mean(G*G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GGj')}#
  	temp_test <- mu_GEE - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEE')}#
  	temp_test <- mu_GEf - mean(G*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEf')}#
  	temp_test <- mu_GEh - mean(G*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEh')}#
 	###############
  	# Harder intermediate quantities involving Z and W#
  	f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  		( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  			(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  	}#
  	mu_G1_E_Z <- rep(NA, num_Z)#
  	for (i in 1:num_Z) {#
  		mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  		temp_test <- mu_G1_E_Z[i] - mean(G1*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_Z')}#
  	}#
  	mu_G1_E_W <- rep(NA, num_W)#
  	f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  		( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  			(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  		temp_test <- mu_G1_E_W[i] - mean(G1*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_W')}#
	}#
#
	mu_G1_E_WW <- rep(NA, num_W)#
  	f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  			sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_E_WW[i] - mean(G1*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_WW')}#
  	}#
    mu_G1_W_EE <- rep(NA, num_W)#
  	f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_W_EE[i] - mean(G1*W[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_W_EE')}#
  	}#
#
    mu_G1_Z_EE  <- rep(NA, num_Z)#
  	f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  		( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}	#
  	for (i in 1:num_Z) {#
  		mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  		temp_test <- mu_G1_Z_EE[i] - mean(G1*Z[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_Z_EE')}#
 	}#
  	###############
  	# Check higher orders with Z and W#
  	MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  	MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW		# Vector#
  	MU_GEM <-	2*mu_G1_E_WW				# Vector#
  	MU_GhW <- 2*mu_G1_W_EE#
  	MU_GhZ <- 2*mu_G1_Z_EE#
  	# Test#
 	for (i in 1:num_Z) { 	#
  		temp_test <- MU_GEZ[i] - mean(G*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEZ')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GEW[i] - mean(G*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEW')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GEM[i] - mean(G*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEM')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GhW[i] - mean(G*E*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GhW')}#
  	}#
  	for (i in 1:num_Z) {#
  		temp_test <- MU_GhZ[i] - mean(G*E*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GhZ')}#
	}#
  	cat('Done')#
}
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
#' GE_translate_inputs.R#
#'#
#' Internal function called by GE_bias_normal.R and GE_scoreeq_sim.R.#
#' Translate the rho_list inputs and return a total covariance matrix for simulation/#
#' checking validity of covariance structure.#
#' #
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW. If Z or M are vectors then terms like cov_GZ should be vectors #
#' (in the appropriate order).#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#
GE_translate_inputs <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL)#
{#
	# First, make sure we got good inputs#
  	if (length(beta_list) != 6 | length(rho_list) != 6 | class(beta_list) != 'list' | class(rho_list) != 'list')#
  	{#
  	  stop('Input vectors not the right size!')#
  	}#
#
	# How long are these vectors?  Remember that W is the same length as M by assumption.#
  	num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
  	num_rho <- 2*(num_Z+num_W) + num_Z*num_W + 1#
  	# Make sure we have compatible lengths for rho_list#
    if (length(rho_list[[2]]) != num_Z | length(rho_list[[3]]) != num_Z | length(rho_list[[4]]) != num_W#
   			| length(rho_list[[5]]) != num_W | length(rho_list[[6]]) != num_Z*num_W) {#
   		stop('Incompatible number of elements in beta/rho_list')#
   	}#
   	# Fill in our covariances.#
   	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
   	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
   	#################################################################
    # Build our covariance matrix in steps.#
    # The 3x3 in the top left is always the same to build, vectors or not.#
    w <- qnorm(1-prob_G)					# Threshold for generating G#
    r_GE <- rho_GE / (2*dnorm(w))	#
    sig_mat_GE <- matrix(data=c(1, 0, r_GE, 0, 1, r_GE, r_GE, r_GE, 1), nrow=3) #
    # Build the p*3 matrix that describes Z with G1,G2,E#
    sig_mat_Z_column <- matrix(data=NA, nrow=num_Z, ncol=3)#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    for (i in 1:num_Z) {#
    	sig_mat_Z_column[i,] <- c(r_GZ[i], r_GZ[i], rho_EZ[i])#
    }#
    # Build the q*3 matrix that describes W with G1,G2,E#
    sig_mat_W_column <- matrix(data=NA, nrow=num_W, ncol=3)#
    r_GW <- rho_GW / (2*dnorm(w))#
    for (i in 1:num_W) {#
    	sig_mat_W_column[i,] <- c(r_GW[i], r_GW[i], rho_EW[i])#
    }#
    # Build the p*q matrix that describes Z with W#
    sig_mat_Z_W <- matrix(data=NA, nrow=num_Z, ncol=num_W)#
    for (i in 1:num_Z) {#
    	start_ind <- (i-1)*num_W+1#
    	end_ind <- i*num_W#
    	sig_mat_Z_W[i,] <- rho_ZW[start_ind:end_ind]#
    }#
    # If Z or W vectorized, build the ZZ and WW covariance matrices too#
    if (num_Z > 1) {#
    	sig_mat_ZZ <- matrix(data=0, nrow=num_Z, ncol=num_Z)#
    	sig_mat_ZZ[upper.tri(sig_mat_ZZ)] <- cov_Z#
    	sig_mat_ZZ <- sig_mat_ZZ + t(sig_mat_ZZ)#
    	diag(sig_mat_ZZ) <- 1#
    } else {#
    	sig_mat_ZZ <- matrix(data=1, nrow=1, ncol=1)#
    }#
    if (num_W > 1) {#
    	sig_mat_WW <- matrix(data=0, nrow=num_W, ncol=num_W)#
    	sig_mat_WW[upper.tri(sig_mat_WW)] <- cov_W#
    	sig_mat_WW <- sig_mat_WW + t(sig_mat_WW)#
    	diag(sig_mat_WW) <- 1#
    } else {#
    	sig_mat_WW <- matrix(data=1, nrow=1, ncol=1)#
    }#
    # Now put it all together#
    sig_mat_total <- matrix(data=NA, nrow=(3+num_Z+num_W), ncol=(3+num_Z+num_W))#
    sig_mat_total[1:3, 1:3] <- sig_mat_GE#
    sig_mat_total[4:(3+num_Z), 1:3] <- sig_mat_Z_column#
    sig_mat_total[1:3, 4:(3+num_Z)] <- t(sig_mat_Z_column)#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 1:3] <- sig_mat_W_column#
    sig_mat_total[1:3, (4+num_Z):(3+num_Z+num_W)] <- t(sig_mat_W_column)#
    sig_mat_total[4:(3+num_Z), 4:(3+num_Z)] <- sig_mat_ZZ#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_WW#
    sig_mat_total[4:(3+num_Z), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_Z_W#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 4:(3+num_Z)] <- t(sig_mat_Z_W)#
    if (!isSymmetric(sig_mat_total)) {stop("Problem building covariance matrix!")}#
    # Now make sure we can actually generate data with this structure#
    test_data <- tryCatch(rmvnorm(n=1, sigma=sig_mat_total), #
    				warning=function(w) w, error=function(e) e)#
    if (class(test_data)[1] != 'matrix') {stop('You specified an impossible covariance matrix!')}#
    return(list(sig_mat_total=sig_mat_total, sig_mat_ZZ=sig_mat_ZZ, sig_mat_WW=sig_mat_WW))#
}
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_Z <- NULL#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_W <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_W <- NULL#
}#
#
# Test first#
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
# First, make sure we got good inputs#
  	if (length(beta_list) != 6 | length(rho_list) != 6 | class(beta_list) != 'list' | class(rho_list) != 'list')#
  	{#
  	  stop('Input vectors not the right size!')#
  	}#
#
	# How long are these vectors?  Remember that W is the same length as M by assumption.#
  	num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
  	num_rho <- 2*(num_Z+num_W) + num_Z*num_W + 1#
  	# Make sure we have compatible lengths for rho_list#
    if (length(rho_list[[2]]) != num_Z | length(rho_list[[3]]) != num_Z | length(rho_list[[4]]) != num_W#
   			| length(rho_list[[5]]) != num_W | length(rho_list[[6]]) != num_Z*num_W) {#
   		stop('Incompatible number of elements in beta/rho_list')#
   	}#
   	# Fill in our covariances.#
   	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
   	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
   	#################################################################
    # Build our covariance matrix in steps.#
    # The 3x3 in the top left is always the same to build, vectors or not.#
    w <- qnorm(1-prob_G)					# Threshold for generating G#
    r_GE <- rho_GE / (2*dnorm(w))	#
    sig_mat_GE <- matrix(data=c(1, 0, r_GE, 0, 1, r_GE, r_GE, r_GE, 1), nrow=3) #
    # Build the p*3 matrix that describes Z with G1,G2,E#
    sig_mat_Z_column <- matrix(data=NA, nrow=num_Z, ncol=3)#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    for (i in 1:num_Z) {#
    	sig_mat_Z_column[i,] <- c(r_GZ[i], r_GZ[i], rho_EZ[i])#
    }#
    # Build the q*3 matrix that describes W with G1,G2,E#
    sig_mat_W_column <- matrix(data=NA, nrow=num_W, ncol=3)#
    r_GW <- rho_GW / (2*dnorm(w))#
    for (i in 1:num_W) {#
    	sig_mat_W_column[i,] <- c(r_GW[i], r_GW[i], rho_EW[i])#
    }#
    # Build the p*q matrix that describes Z with W#
    sig_mat_Z_W <- matrix(data=NA, nrow=num_Z, ncol=num_W)#
    for (i in 1:num_Z) {#
    	start_ind <- (i-1)*num_W+1#
    	end_ind <- i*num_W#
    	sig_mat_Z_W[i,] <- rho_ZW[start_ind:end_ind]#
    }#
    # If Z or W vectorized, build the ZZ and WW covariance matrices too#
    if (num_Z > 1) {#
    	sig_mat_ZZ <- matrix(data=0, nrow=num_Z, ncol=num_Z)#
    	sig_mat_ZZ[upper.tri(sig_mat_ZZ)] <- cov_Z#
    	sig_mat_ZZ <- sig_mat_ZZ + t(sig_mat_ZZ)#
    	diag(sig_mat_ZZ) <- 1#
    } else {#
    	sig_mat_ZZ <- matrix(data=1, nrow=1, ncol=1)#
    }#
    if (num_W > 1) {#
    	sig_mat_WW <- matrix(data=0, nrow=num_W, ncol=num_W)#
    	sig_mat_WW[upper.tri(sig_mat_WW)] <- cov_W#
    	sig_mat_WW <- sig_mat_WW + t(sig_mat_WW)#
    	diag(sig_mat_WW) <- 1#
    } else {#
    	sig_mat_WW <- matrix(data=1, nrow=1, ncol=1)#
    }#
    # Now put it all together#
    sig_mat_total <- matrix(data=NA, nrow=(3+num_Z+num_W), ncol=(3+num_Z+num_W))#
    sig_mat_total[1:3, 1:3] <- sig_mat_GE#
    sig_mat_total[4:(3+num_Z), 1:3] <- sig_mat_Z_column#
    sig_mat_total[1:3, 4:(3+num_Z)] <- t(sig_mat_Z_column)#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 1:3] <- sig_mat_W_column#
    sig_mat_total[1:3, (4+num_Z):(3+num_Z+num_W)] <- t(sig_mat_W_column)#
    sig_mat_total[4:(3+num_Z), 4:(3+num_Z)] <- sig_mat_ZZ#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_WW#
    sig_mat_total[4:(3+num_Z), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_Z_W#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 4:(3+num_Z)] <- t(sig_mat_Z_W)#
    if (!isSymmetric(sig_mat_total)) {stop("Problem building covariance matrix!")}
sig_mat_total
#' GE_test_moment_calcs.R#
#'#
#' An internal test function to ensure the higher order moments (covariances)#
#' calculated in GE_bias_normal_squaredmis.R are correct.#
#'#
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.  If Z and/or W include multiple covariates, then#
#' terms like cov_GZ should be a vector.  #
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector. If Z or M are vectors, then cov_ZW should be a vector in the order#
#' (cov(Z_1,W_1),cov(Z_1,W_2),...,cov(Z_1,W_q),cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is #
#' a vector of length p and W is a vector of length q.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#' @param num_sum Number of subjects to do the simulation with.#
#' @param test_threshold How much margin for error on tests?#
#'#
#' @keywords validation#
#' @export#
#' @examples #
#' test_moment_calcs(beta_list=runif(n=6, min=0, max=1), rho_list=rep(0.3,1), prob_G=0.3)#
#
GE_test_moments_calcs <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL, num_sub=1000000, test_threshold=0.01)#
{#
	# Need survival function#
  	surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_list=beta_list, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	# Generate test data#
	test_data <- rmvnorm(n=num_sub, sigma=sig_mat)#
	# Get the individual components#
  	G1 <- as.numeric(test_data[,1] > w)#
  	G2 <- as.numeric(test_data[,2] > w)#
  	G <- G1 + G2 - 2*prob_G#
	E <- test_data[,3]#
	Z <- as.matrix(test_data[,4:(3+num_Z)])#
	W <- as.matrix(test_data[,(4+num_Z):(3+num_Z+num_W)])#
  	# Start testing with calculated G covariances#
  	temp_test <- rho_GE - cov(G,E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with rho_GE')}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- rho_GZ[i] - cov(G,Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with rho_GZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- rho_GW[i] - cov(G,W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with rho_GW')}#
  	}#
  	 #########################
 	 # More covariances#
  	 mu_GE <- rho_GE#
 	 mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
 	 mu_Gh <- mu_Gf#
 	 mu_GG <- 2*prob_G*(1-prob_G)#
 	 MU_GZ <- rho_GZ  	# Vector#
 	 MU_GW <- rho_GW		# Vector#
 	 MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
 	 MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
 	 MU_EZ <- rho_EZ			# Vector#
 	 MU_EW <- rho_EW			# Vector#
 	 mu_EE <- 1#
 	 mu_Ef <- 0#
 	 MU_fZ <- 	rep(0, num_Z)	# Vector#
 	 MU_fW <- 	rep(0, num_W)		# Vector#
 	# Test the above#
  	temp_test <- mu_GE - mean(G*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GE')}#
  	temp_test <- mu_Gf - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_Gf')}#
  	temp_test <- mu_Gh - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_Gh')}#
  	temp_test <- mu_GG - mean(G*G)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GG')}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_GZ[i] - mean(G*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_GW[i] - mean(G*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GW')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_GM[i]- mean(G*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GM')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EM[i] - mean(E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EM')}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_EZ[i] - mean(E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EW[i] - mean(E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EW')}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_fZ[i] - mean(E*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_fZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_fW[i] - mean(E*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_fW')}#
  	}#
   	#########################
 	# Matrix covariances#
 	MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  	MU_WZ <- t(MU_ZW)	 #
 	MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
 	MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  	MU_ZZ <- sig_mat_ZZ 		# Matrix#
  	MU_WW <- sig_mat_WW		# Matrix#
  	# Check them#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZW[i,j] - mean(Z[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZW')}#
  		}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZM[i,j] - mean(Z[,i]*W[,j]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZM')}#
  		}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_WM[i,j] - mean(W[,i]*W[,j]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_WM')}#
  		}#
  	}	#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_Z)#
  		{#
  			temp_test <- MU_ZZ[i,j] - mean(Z[,i]*Z[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZZ')}#
  		}#
  	}	#
  	for (i in 1:num_W)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_WW[i,j] - mean(W[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_WM')}#
  		}#
  	}	#
    #########################
 	# Higher order moments, intermediate quantities#
  	mu_G1_E <- r_GE*dnorm(w)#
  	mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  	mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_E <- function(x,w,r_GE) {#
  		x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_EE <- function(x,w,r_GE) {#
  		x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_EEE <- function(x,w,r_GE) {#
  		x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	# Higher order moments, see gen_cor_bin_normal to see how to do these#
  	mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  	mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  	mu_GEE <- mu_Gf#
  	mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  	mu_GEh <- mu_GEf#
  	mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  	mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  	mu_GGEh <- mu_GGEf#
 	##############  	#
  	# Check	#
  	temp_test <- mu_G1_E - mean(G1*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E')}#
  	temp_test <- mu_G1_EE - mean(G1*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_EE')}#
  	temp_test <- mu_G1_EEE - mean(G1*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_EEE')}#
  	temp_test <- mu_G1_G2_E - mean(G1*G2*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_E')}#
  	temp_test <- mu_G1_G2_EE - mean(G1*G2*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_EE')}#
  	temp_test <- mu_G1_G2_EEE - mean(G1*G2*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_EEE')}#
#
  	temp_test <- mu_GGE - mean(G*G*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GGE')}#
  	temp_test <- mu_GGh - mean(G*G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GGj')}#
  	temp_test <- mu_GEE - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEE')}#
  	temp_test <- mu_GEf - mean(G*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEf')}#
  	temp_test <- mu_GEh - mean(G*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEh')}#
 	###############
  	# Harder intermediate quantities involving Z and W#
  	f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  		( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  			(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  	}#
  	mu_G1_E_Z <- rep(NA, num_Z)#
  	for (i in 1:num_Z) {#
  		mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  		temp_test <- mu_G1_E_Z[i] - mean(G1*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_Z')}#
  	}#
  	mu_G1_E_W <- rep(NA, num_W)#
  	f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  		( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  			(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  		temp_test <- mu_G1_E_W[i] - mean(G1*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_W')}#
	}#
#
	mu_G1_E_WW <- rep(NA, num_W)#
  	f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  			sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_E_WW[i] - mean(G1*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_WW')}#
  	}#
    mu_G1_W_EE <- rep(NA, num_W)#
  	f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_W_EE[i] - mean(G1*W[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_W_EE')}#
  	}#
#
    mu_G1_Z_EE  <- rep(NA, num_Z)#
  	f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  		( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}	#
  	for (i in 1:num_Z) {#
  		mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  		temp_test <- mu_G1_Z_EE[i] - mean(G1*Z[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_Z_EE')}#
 	}#
  	###############
  	# Check higher orders with Z and W#
  	MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  	MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW		# Vector#
  	MU_GEM <-	2*mu_G1_E_WW				# Vector#
  	MU_GhW <- 2*mu_G1_W_EE#
  	MU_GhZ <- 2*mu_G1_Z_EE#
  	# Test#
 	for (i in 1:num_Z) { 	#
  		temp_test <- MU_GEZ[i] - mean(G*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEZ')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GEW[i] - mean(G*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEW')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GEM[i] - mean(G*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEM')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GhW[i] - mean(G*E*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GhW')}#
  	}#
  	for (i in 1:num_Z) {#
  		temp_test <- MU_GhZ[i] - mean(G*E*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GhZ')}#
	}#
  	cat('Done')#
}
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_Z <- NULL#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_W <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_W <- NULL#
}#
#
# Test first#
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
beta_list
rho_list
prob_G
cov_Z
cov_W
surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_list=beta_list, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	# Generate test data#
	test_data <- rmvnorm(n=num_sub, sigma=sig_mat)#
	# Get the individual components#
  	G1 <- as.numeric(test_data[,1] > w)#
  	G2 <- as.numeric(test_data[,2] > w)#
  	G <- G1 + G2 - 2*prob_G#
	E <- test_data[,3]#
	Z <- as.matrix(test_data[,4:(3+num_Z)])#
	W <- as.matrix(test_data[,(4+num_Z):(3+num_Z+num_W)])
sig_mat
cov_Z
cov_W
beta-list
rho_list
beta_list
prob_G
# First, make sure we got good inputs#
  	if (length(beta_list) != 6 | length(rho_list) != 6 | class(beta_list) != 'list' | class(rho_list) != 'list')#
  	{#
  	  stop('Input vectors not the right size!')#
  	}#
#
	# How long are these vectors?  Remember that W is the same length as M by assumption.#
  	num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
  	num_rho <- 2*(num_Z+num_W) + num_Z*num_W + 1#
  	# Make sure we have compatible lengths for rho_list#
    if (length(rho_list[[2]]) != num_Z | length(rho_list[[3]]) != num_Z | length(rho_list[[4]]) != num_W#
   			| length(rho_list[[5]]) != num_W | length(rho_list[[6]]) != num_Z*num_W) {#
   		stop('Incompatible number of elements in beta/rho_list')#
   	}#
   	# Fill in our covariances.#
   	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
   	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
   	#################################################################
    # Build our covariance matrix in steps.#
    # The 3x3 in the top left is always the same to build, vectors or not.#
    w <- qnorm(1-prob_G)					# Threshold for generating G#
    r_GE <- rho_GE / (2*dnorm(w))	#
    sig_mat_GE <- matrix(data=c(1, 0, r_GE, 0, 1, r_GE, r_GE, r_GE, 1), nrow=3) #
    # Build the p*3 matrix that describes Z with G1,G2,E#
    sig_mat_Z_column <- matrix(data=NA, nrow=num_Z, ncol=3)#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    for (i in 1:num_Z) {#
    	sig_mat_Z_column[i,] <- c(r_GZ[i], r_GZ[i], rho_EZ[i])#
    }#
    # Build the q*3 matrix that describes W with G1,G2,E#
    sig_mat_W_column <- matrix(data=NA, nrow=num_W, ncol=3)#
    r_GW <- rho_GW / (2*dnorm(w))#
    for (i in 1:num_W) {#
    	sig_mat_W_column[i,] <- c(r_GW[i], r_GW[i], rho_EW[i])#
    }#
    # Build the p*q matrix that describes Z with W#
    sig_mat_Z_W <- matrix(data=NA, nrow=num_Z, ncol=num_W)#
    for (i in 1:num_Z) {#
    	start_ind <- (i-1)*num_W+1#
    	end_ind <- i*num_W#
    	sig_mat_Z_W[i,] <- rho_ZW[start_ind:end_ind]#
    }#
    # If Z or W vectorized, build the ZZ and WW covariance matrices too#
    if (num_Z > 1) {#
    	sig_mat_ZZ <- matrix(data=0, nrow=num_Z, ncol=num_Z)#
    	sig_mat_ZZ[upper.tri(sig_mat_ZZ)] <- cov_Z#
    	sig_mat_ZZ <- sig_mat_ZZ + t(sig_mat_ZZ)#
    	diag(sig_mat_ZZ) <- 1#
    } else {#
    	sig_mat_ZZ <- matrix(data=1, nrow=1, ncol=1)#
    }#
    if (num_W > 1) {#
    	sig_mat_WW <- matrix(data=0, nrow=num_W, ncol=num_W)#
    	sig_mat_WW[upper.tri(sig_mat_WW)] <- cov_W#
    	sig_mat_WW <- sig_mat_WW + t(sig_mat_WW)#
    	diag(sig_mat_WW) <- 1#
    } else {#
    	sig_mat_WW <- matrix(data=1, nrow=1, ncol=1)#
    }#
    # Now put it all together#
    sig_mat_total <- matrix(data=NA, nrow=(3+num_Z+num_W), ncol=(3+num_Z+num_W))#
    sig_mat_total[1:3, 1:3] <- sig_mat_GE#
    sig_mat_total[4:(3+num_Z), 1:3] <- sig_mat_Z_column#
    sig_mat_total[1:3, 4:(3+num_Z)] <- t(sig_mat_Z_column)#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 1:3] <- sig_mat_W_column#
    sig_mat_total[1:3, (4+num_Z):(3+num_Z+num_W)] <- t(sig_mat_W_column)#
    sig_mat_total[4:(3+num_Z), 4:(3+num_Z)] <- sig_mat_ZZ#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_WW#
    sig_mat_total[4:(3+num_Z), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_Z_W#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 4:(3+num_Z)] <- t(sig_mat_Z_W)
sig_mat_WW
sig_mat_total
if (!isSymmetric(sig_mat_total)) {stop("Problem building covariance matrix!")}#
    # Now make sure we can actually generate data with this structure#
    test_data <- tryCatch(rmvnorm(n=1, sigma=sig_mat_total), #
    				warning=function(w) w, error=function(e) e)#
    if (class(test_data)[1] != 'matrix') {stop('You specified an impossible covariance matrix!')}
#' GE_test_moment_calcs.R#
#'#
#' An internal test function to ensure the higher order moments (covariances)#
#' calculated in GE_bias_normal_squaredmis.R are correct.#
#'#
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.  If Z and/or W include multiple covariates, then#
#' terms like cov_GZ should be a vector.  #
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector. If Z or M are vectors, then cov_ZW should be a vector in the order#
#' (cov(Z_1,W_1),cov(Z_1,W_2),...,cov(Z_1,W_q),cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is #
#' a vector of length p and W is a vector of length q.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#' @param num_sum Number of subjects to do the simulation with.#
#' @param test_threshold How much margin for error on tests?#
#'#
#' @keywords validation#
#' @export#
#' @examples #
#' test_moment_calcs(beta_list=runif(n=6, min=0, max=1), rho_list=rep(0.3,1), prob_G=0.3)#
#
GE_test_moments_calcs <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL, num_sub=1000000, test_threshold=0.01)#
{#
	# Need survival function#
  	surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_list=beta_list, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat_total#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	# Generate test data#
	test_data <- rmvnorm(n=num_sub, sigma=sig_mat)#
	# Get the individual components#
  	G1 <- as.numeric(test_data[,1] > w)#
  	G2 <- as.numeric(test_data[,2] > w)#
  	G <- G1 + G2 - 2*prob_G#
	E <- test_data[,3]#
	Z <- as.matrix(test_data[,4:(3+num_Z)])#
	W <- as.matrix(test_data[,(4+num_Z):(3+num_Z+num_W)])#
  	# Start testing with calculated G covariances#
  	temp_test <- rho_GE - cov(G,E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with rho_GE')}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- rho_GZ[i] - cov(G,Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with rho_GZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- rho_GW[i] - cov(G,W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with rho_GW')}#
  	}#
  	 #########################
 	 # More covariances#
  	 mu_GE <- rho_GE#
 	 mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
 	 mu_Gh <- mu_Gf#
 	 mu_GG <- 2*prob_G*(1-prob_G)#
 	 MU_GZ <- rho_GZ  	# Vector#
 	 MU_GW <- rho_GW		# Vector#
 	 MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
 	 MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
 	 MU_EZ <- rho_EZ			# Vector#
 	 MU_EW <- rho_EW			# Vector#
 	 mu_EE <- 1#
 	 mu_Ef <- 0#
 	 MU_fZ <- 	rep(0, num_Z)	# Vector#
 	 MU_fW <- 	rep(0, num_W)		# Vector#
 	# Test the above#
  	temp_test <- mu_GE - mean(G*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GE')}#
  	temp_test <- mu_Gf - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_Gf')}#
  	temp_test <- mu_Gh - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_Gh')}#
  	temp_test <- mu_GG - mean(G*G)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GG')}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_GZ[i] - mean(G*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_GW[i] - mean(G*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GW')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_GM[i]- mean(G*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_GM')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EM[i] - mean(E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EM')}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_EZ[i] - mean(E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_EW[i] - mean(E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_EW')}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		temp_test <- MU_fZ[i] - mean(E*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_fZ')}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		temp_test <- MU_fW[i] - mean(E*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_fW')}#
  	}#
   	#########################
 	# Matrix covariances#
 	MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  	MU_WZ <- t(MU_ZW)	 #
 	MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
 	MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  	MU_ZZ <- sig_mat_ZZ 		# Matrix#
  	MU_WW <- sig_mat_WW		# Matrix#
  	# Check them#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZW[i,j] - mean(Z[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZW')}#
  		}#
  	}#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_ZM[i,j] - mean(Z[,i]*W[,j]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZM')}#
  		}#
  	}#
  	for (i in 1:num_W)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_WM[i,j] - mean(W[,i]*W[,j]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_WM')}#
  		}#
  	}	#
  	for (i in 1:num_Z)#
  	{#
  		for (j in 1:num_Z)#
  		{#
  			temp_test <- MU_ZZ[i,j] - mean(Z[,i]*Z[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_ZZ')}#
  		}#
  	}	#
  	for (i in 1:num_W)#
  	{#
  		for (j in 1:num_W)#
  		{#
  			temp_test <- MU_WW[i,j] - mean(W[,i]*W[,j])#
  			if (abs(temp_test) > test_threshold) {warning('Problem with mu_WM')}#
  		}#
  	}	#
    #########################
 	# Higher order moments, intermediate quantities#
  	mu_G1_E <- r_GE*dnorm(w)#
  	mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  	mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_E <- function(x,w,r_GE) {#
  		x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_EE <- function(x,w,r_GE) {#
  		x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  	f_G1_G2_EEE <- function(x,w,r_GE) {#
  		x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  	}#
  	mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  	# Higher order moments, see gen_cor_bin_normal to see how to do these#
  	mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  	mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  	mu_GEE <- mu_Gf#
  	mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  	mu_GEh <- mu_GEf#
  	mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  	mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  	mu_GGEh <- mu_GGEf#
 	##############  	#
  	# Check	#
  	temp_test <- mu_G1_E - mean(G1*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E')}#
  	temp_test <- mu_G1_EE - mean(G1*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_EE')}#
  	temp_test <- mu_G1_EEE - mean(G1*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_EEE')}#
  	temp_test <- mu_G1_G2_E - mean(G1*G2*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_E')}#
  	temp_test <- mu_G1_G2_EE - mean(G1*G2*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_EE')}#
  	temp_test <- mu_G1_G2_EEE - mean(G1*G2*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_G2_EEE')}#
#
  	temp_test <- mu_GGE - mean(G*G*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GGE')}#
  	temp_test <- mu_GGh - mean(G*G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GGj')}#
  	temp_test <- mu_GEE - mean(G*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEE')}#
  	temp_test <- mu_GEf - mean(G*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEf')}#
  	temp_test <- mu_GEh - mean(G*E*E*E)#
  	if (abs(temp_test) > test_threshold) {warning('Problem with mu_GEh')}#
 	###############
  	# Harder intermediate quantities involving Z and W#
  	f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  		( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  			(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  	}#
  	mu_G1_E_Z <- rep(NA, num_Z)#
  	for (i in 1:num_Z) {#
  		mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  		temp_test <- mu_G1_E_Z[i] - mean(G1*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_Z')}#
  	}#
  	mu_G1_E_W <- rep(NA, num_W)#
  	f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  		( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  			(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  		temp_test <- mu_G1_E_W[i] - mean(G1*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_W')}#
	}#
#
	mu_G1_E_WW <- rep(NA, num_W)#
  	f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  			sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_E_WW[i] - mean(G1*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_E_WW')}#
  	}#
    mu_G1_W_EE <- rep(NA, num_W)#
  	f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  		( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}#
  	for (i in 1:num_W) {#
  		mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  		temp_test <- mu_G1_W_EE[i] - mean(G1*W[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_W_EE')}#
  	}#
#
    mu_G1_Z_EE  <- rep(NA, num_Z)#
  	f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  		( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  			sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  	}	#
  	for (i in 1:num_Z) {#
  		mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  		temp_test <- mu_G1_Z_EE[i] - mean(G1*Z[,i]*E*E)#
  		if (abs(temp_test) > test_threshold) {warning('Problem with mu_G1_Z_EE')}#
 	}#
  	###############
  	# Check higher orders with Z and W#
  	MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  	MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW		# Vector#
  	MU_GEM <-	2*mu_G1_E_WW				# Vector#
  	MU_GhW <- 2*mu_G1_W_EE#
  	MU_GhZ <- 2*mu_G1_Z_EE#
  	# Test#
 	for (i in 1:num_Z) { 	#
  		temp_test <- MU_GEZ[i] - mean(G*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEZ')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GEW[i] - mean(G*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEW')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GEM[i] - mean(G*E*W[,i]*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GEM')}#
  	}#
  	for (i in 1:num_W) {#
  		temp_test <- MU_GhW[i] - mean(G*E*E*W[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GhW')}#
  	}#
  	for (i in 1:num_Z) {#
  		temp_test <- MU_GhZ[i] - mean(G*E*E*Z[,i])#
  		if (abs(temp_test) > test_threshold) {warning('Problem with MU_GhZ')}#
	}#
  	cat('Done')#
}
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
#' GE_scoreeq_sim_vec.R#
#'#
#' VECTORIZED VERSION#
#'#
#' Here we perform simulation to verify that we have solved for#
#' the correct alpha values. #
#' No vector covariates yet, just scalars.#
#' Assume all covariates are marginally normal and jointly multivariate normal,#
#' with the exception of G, which is generated by thresholding two (pairwise independent) normals.#
#' Assume all covariates have variance 1, except for G.#
#  Assume all fitted covariates are centered at 0.#
#' Assume F=E^2 and W=M^2.#
#' #
#' @param beta_list A vector of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors and#
#' beta_list should be a LIST! If it is not a list, then Z and M will be treated as scalars.#
#' @param rho_vec A vector of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' and rho_vec should be a LIST!#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#'#
#' @keywords simulation#
#' @export#
#' @examples #
#' library(mvtnorm)#
#' rho_vec <- rep(0.3, 6)#
#' beta_list <- runif(6)#
#' prob_G <- runif(1, min=0.05, max=0.95)#
#' GE_bias_results <- GE_bias_normal_squaredmis(beta_list, mu_vec, rho_vec)#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_vec, GE_bias_results$cov_vec,#
#' 		GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW,#
#' 		GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_vec)#
#' GE_scoreeq_sim(beta_list=beta_list, prob_G, rho_vec=rho_vec)#
#
GE_scoreeq_sim <- function(num_sims=5000, num_sub=2000, beta_list, prob_G, rho_vec, cov_Z=NULL, cov_W=NULL)#
{#
	# Need survival function#
	surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_list=beta_list, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	results <- matrix(data=NA, nrow=num_sims, ncol=(4+num_Z+num_W))#
	for(i in 1:num_sims)#
	{#
		# Sim covariates#
		sim_data <- mvtnorm::rmvnorm(n=num_sub, mean=c(rep(0,3+num_Z+num_W)), sigma=sig_mat_total)		#
		snp1 <- as.numeric(sim_data[,1]>w)#
		snp2 <- as.numeric(sim_data[,2]>w)#
		G <- snp1 + snp2 - 2*prob_G#
		E <- sim_data[,3]#
		Z <- sim_data[,4:(3+num_Z)]#
		W <- sim_data[,(4+num_Z):(3+num_Z+num_W)]#
#
		# Sim outcome#
		d_right <- cbind(1, G, E^2, G*E^2, Z, W^2)#
		d_wrong <- cbind(1, G, E, G*E, Z, W)#
		Y <- d_right %*% unlist(beta_list) + rnorm(num_sub)#
		# Solve for beta_hat#
		b_hat <- solve(t(d_wrong) %*% d_wrong) %*% t(d_wrong) %*% Y#
		results[i,] <- b_hat#
		# Checkpoint#
		if (i%%1000 == 0) {cat(i, "done\n")}#
	}#
	colnames(results) <- c('alpha_0', 'alpha_G', 'alpha_E', 'alpha_I', 'ALPHA_Z', 'ALPHA_W')#
	sim_alpha <- apply(results, 2, mean)#
	return(sim_alpha)#
}
#' GE_scoreeq_sim_vec.R#
#'#
#' VECTORIZED VERSION#
#'#
#' Here we perform simulation to verify that we have solved for#
#' the correct alpha values. #
#' No vector covariates yet, just scalars.#
#' Assume all covariates are marginally normal and jointly multivariate normal,#
#' with the exception of G, which is generated by thresholding two (pairwise independent) normals.#
#' Assume all covariates have variance 1, except for G.#
#  Assume all fitted covariates are centered at 0.#
#' Assume F=E^2 and W=M^2.#
#' #
#' @param beta_list A vector of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors and#
#' beta_list should be a LIST! If it is not a list, then Z and M will be treated as scalars.#
#' @param rho_list A vector of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' and rho_list should be a LIST!#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#'#
#' @keywords simulation#
#' @export#
#' @examples #
#' library(mvtnorm)#
#' rho_list <- rep(0.3, 6)#
#' beta_list <- runif(6)#
#' prob_G <- runif(1, min=0.05, max=0.95)#
#' GE_bias_results <- GE_bias_normal_squaredmis(beta_list, mu_vec, rho_list)#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_vec, GE_bias_results$cov_vec,#
#' 		GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW,#
#' 		GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_vec)#
#' GE_scoreeq_sim(beta_list=beta_list, prob_G, rho_list=rho_list)#
#
GE_scoreeq_sim <- function(num_sims=5000, num_sub=2000, beta_list, prob_G, rho_list, cov_Z=NULL, cov_W=NULL)#
{#
	# Need survival function#
	surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_list=beta_list, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	results <- matrix(data=NA, nrow=num_sims, ncol=(4+num_Z+num_W))#
	for(i in 1:num_sims)#
	{#
		# Sim covariates#
		sim_data <- mvtnorm::rmvnorm(n=num_sub, mean=c(rep(0,3+num_Z+num_W)), sigma=sig_mat_total)		#
		snp1 <- as.numeric(sim_data[,1]>w)#
		snp2 <- as.numeric(sim_data[,2]>w)#
		G <- snp1 + snp2 - 2*prob_G#
		E <- sim_data[,3]#
		Z <- sim_data[,4:(3+num_Z)]#
		W <- sim_data[,(4+num_Z):(3+num_Z+num_W)]#
#
		# Sim outcome#
		d_right <- cbind(1, G, E^2, G*E^2, Z, W^2)#
		d_wrong <- cbind(1, G, E, G*E, Z, W)#
		Y <- d_right %*% unlist(beta_list) + rnorm(num_sub)#
		# Solve for beta_hat#
		b_hat <- solve(t(d_wrong) %*% d_wrong) %*% t(d_wrong) %*% Y#
		results[i,] <- b_hat#
		# Checkpoint#
		if (i%%1000 == 0) {cat(i, "done\n")}#
	}#
	colnames(results) <- c('alpha_0', 'alpha_G', 'alpha_E', 'alpha_I', 'ALPHA_Z', 'ALPHA_W')#
	sim_alpha <- apply(results, 2, mean)#
	return(sim_alpha)#
}
#' GE_scoreeq_sim_vec.R#
#'#
#' VECTORIZED VERSION#
#'#
#' Here we perform simulation to verify that we have solved for#
#' the correct alpha values. #
#' No vector covariates yet, just scalars.#
#' Assume all covariates are marginally normal and jointly multivariate normal,#
#' with the exception of G, which is generated by thresholding two (pairwise independent) normals.#
#' Assume all covariates have variance 1, except for G.#
#  Assume all fitted covariates are centered at 0.#
#' Assume F=E^2 and W=M^2.#
#' #
#' @param beta_list A vector of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors and#
#' beta_list should be a LIST! If it is not a list, then Z and M will be treated as scalars.#
#' @param rho_list A vector of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' and rho_list should be a LIST!#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#'#
#' @keywords simulation#
#' @export#
#' @examples #
#' library(mvtnorm)#
#' rho_list <- rep(0.3, 6)#
#' beta_list <- runif(6)#
#' prob_G <- runif(1, min=0.05, max=0.95)#
#' GE_bias_results <- GE_bias_normal_squaredmis(beta_list, mu_vec, rho_list)#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_vec, GE_bias_results$cov_vec,#
#' 		GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW,#
#' 		GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_vec)#
#' GE_scoreeq_sim(beta_list=beta_list, prob_G, rho_list=rho_list)#
#
GE_scoreeq_sim <- function(num_sims=5000, num_sub=2000, beta_list, prob_G, rho_list, cov_Z=NULL, cov_W=NULL)#
{#
	# Need survival function#
	surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_list=beta_list, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	results <- matrix(data=NA, nrow=num_sims, ncol=(4+num_Z+num_W))#
	for(i in 1:num_sims)#
	{#
		# Sim covariates#
		sim_data <- mvtnorm::rmvnorm(n=num_sub, mean=c(rep(0,3+num_Z+num_W)), sigma=sig_mat_total)		#
		snp1 <- as.numeric(sim_data[,1]>w)#
		snp2 <- as.numeric(sim_data[,2]>w)#
		G <- snp1 + snp2 - 2*prob_G#
		E <- sim_data[,3]#
		Z <- sim_data[,4:(3+num_Z)]#
		W <- sim_data[,(4+num_Z):(3+num_Z+num_W)]#
#
		# Sim outcome#
		d_right <- cbind(1, G, E^2, G*E^2, Z, W^2)#
		d_wrong <- cbind(1, G, E, G*E, Z, W)#
		Y <- d_right %*% unlist(beta_list) + rnorm(num_sub)#
		# Solve for beta_hat#
		b_hat <- solve(t(d_wrong) %*% d_wrong) %*% t(d_wrong) %*% Y#
		results[i,] <- b_hat#
		# Checkpoint#
		if (i%%1000 == 0) {cat(i, "done\n")}#
	}#
	colnames(results) <- c('alpha_0', 'alpha_G', 'alpha_E', 'alpha_I', 'ALPHA_Z', 'ALPHA_W')#
	sim_alpha <- apply(results, 2, mean)#
	return(sim_alpha)#
}
GE_scoreeq_sim(beta_list=beta_list, prob_G=prob_G, rho_list=rho_list, cov_Z=cov_Z, cov_W=cov_W)
sims_results <- GE_scoreeq_sim(beta_list=beta_list, prob_G=prob_G, rho_list=rho_list, cov_Z=cov_Z, cov_W=cov_W)
#' GE_scoreeq_sim_vec.R#
#'#
#' VECTORIZED VERSION#
#'#
#' Here we perform simulation to verify that we have solved for#
#' the correct alpha values. #
#' No vector covariates yet, just scalars.#
#' Assume all covariates are marginally normal and jointly multivariate normal,#
#' with the exception of G, which is generated by thresholding two (pairwise independent) normals.#
#' Assume all covariates have variance 1, except for G.#
#  Assume all fitted covariates are centered at 0.#
#' Assume F=E^2 and W=M^2.#
#' #
#' @param beta_list A vector of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors and#
#' beta_list should be a LIST! If it is not a list, then Z and M will be treated as scalars.#
#' @param rho_list A vector of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' and rho_list should be a LIST!#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#'#
#' @keywords simulation#
#' @export#
#' @examples #
#' library(mvtnorm)#
#' rho_list <- rep(0.3, 6)#
#' beta_list <- runif(6)#
#' prob_G <- runif(1, min=0.05, max=0.95)#
#' GE_bias_results <- GE_bias_normal_squaredmis(beta_list, mu_vec, rho_list)#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_vec, GE_bias_results$cov_vec,#
#' 		GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW,#
#' 		GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_vec)#
#' GE_scoreeq_sim(beta_list=beta_list, prob_G, rho_list=rho_list)#
#
GE_scoreeq_sim <- function(num_sims=5000, num_sub=2000, beta_list, prob_G, rho_list, cov_Z=NULL, cov_W=NULL)#
{#
	# Need survival function#
	surv <- function(x) {1-pnorm(x)}#
  	# Fill in our covariances.#
  	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  	# Quantities necessary for calculating higher order moments#
  	w <- qnorm(1-prob_G)					#
    r_GE <- rho_GE / (2*dnorm(w))	#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    r_GW <- rho_GW / (2*dnorm(w))#
    num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
   	# Get the total covariance matrix (also some basic validity checks)#
	translated_inputs <- GE_translate_inputs(beta_list=beta_list, rho_list=rho_list, #
									prob_G=prob_G, cov_Z=cov_Z, cov_W=cov_W)#
	sig_mat <- translated_inputs$sig_mat#
	sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
	sig_mat_WW <- translated_inputs$sig_mat_WW#
	results <- matrix(data=NA, nrow=num_sims, ncol=(4+num_Z+num_W))#
	for(i in 1:num_sims)#
	{#
		# Sim covariates#
		sim_data <- mvtnorm::rmvnorm(n=num_sub, mean=c(rep(0,3+num_Z+num_W)), sigma=sig_mat_total)		#
		snp1 <- as.numeric(sim_data[,1]>w)#
		snp2 <- as.numeric(sim_data[,2]>w)#
		G <- snp1 + snp2 - 2*prob_G#
		E <- sim_data[,3]#
		Z <- sim_data[,4:(3+num_Z)]#
		W <- sim_data[,(4+num_Z):(3+num_Z+num_W)]#
#
		# Sim outcome#
		d_right <- cbind(1, G, E^2, G*E^2, Z, W^2)#
		d_wrong <- cbind(1, G, E, G*E, Z, W)#
		Y <- d_right %*% unlist(beta_list) + rnorm(num_sub)#
		# Solve for beta_hat#
		b_hat <- solve(t(d_wrong) %*% d_wrong) %*% t(d_wrong) %*% Y#
		results[i,] <- b_hat#
		# Checkpoint#
		if (i%%1000 == 0) {cat(i, "done\n")}#
	}#
	colnames(results) <- c('alpha_0', 'alpha_G', 'alpha_E', 'alpha_I', rep('ALPHA_Z',num_Z), rep('ALPHA_W',num_W))#
	sim_alpha <- apply(results, 2, mean)#
	return(sim_alpha)#
}
sims_results <- GE_scoreeq_sim(beta_list=beta_list, prob_G=prob_G, rho_list=rho_list, cov_Z=cov_Z, cov_W=cov_W)
sim_results= sims_results
sim_results
#' GE_bias_normal_squaredmis.R#
#'#
#' A function to calculate the bias in testing for GxE interaction.#
#' Here we make the following assumptions:#
#' (1) All covariates (besides E) are marginally normally distributed with #
#' unit variance.  In addition, E,Z,W have mean 0.#
#' (2) G is generated by means of thresholding two independent normal RVs (jointly generated#
#' with the other covariates) and is centered to have mean 0.#
#' (3) The misspecification is of the form f(E)=h(E)=E^2, and M_j=W_j^2 for all j. In particular,#
#' W always has the same length as M here.#
#' #
#' In this version, some or all covariate terms may not exist, and some or all can be vectors.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors.#
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#' #
#' @keywords bias normal squared_misspecification#
#' @export#
#' @examples #
#' GE_bias_normal_squaredmis( beta_list=runif(n=6, min=0, max=1), rho_list=rep(0.3,1), prob_G=0.3)#
#
GE_bias_normal_squaredmis <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL)#
{#
  # Record some initial quantities#
  num_Z <- length(beta_list[[5]])#
  num_W <- length(beta_list[[6]])#
  rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  beta_0 <- beta_list[[1]]; beta_G <- beta_list[[2]]; beta_E <- beta_list[[3]]#
  beta_I <- beta_list[[4]]; BETA_Z <- beta_list[[5]]; BETA_M <- beta_list[[6]]#
#
  # Some error checking, make sure the covariance matrix is ok#
  translated_inputs <- GE_translate_inputs(beta_list, rho_list, prob_G, cov_Z, cov_W)#
  sig_mat <- translated_inputs$sig_mat_total#
  sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
  sig_mat_WW <- translated_inputs$sig_mat_WW#
  # Obvious and by assumptions#
  MU_Z <- rep(0, num_Z) 		# Some obvious ones#
  MU_M <- rep(1, num_W)		#
  MU_W <- rep(0, num_W)			#
  mu_f <- 1#
  mu_h <- 1#
  # Done translating inputs#
  # Now calculate other necessary terms that have #
  # been determined by our assumptions + inputs#
  #########################
  # Covariances#
  mu_GE <- rho_GE#
  mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
  mu_Gh <- mu_Gf#
  mu_GG <- 2*prob_G*(1-prob_G)#
  MU_GZ <- rho_GZ  	# Vector#
  MU_GW <- rho_GW		# Vector#
  MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
  MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
  MU_EZ <- rho_EZ			# Vector#
  MU_EW <- rho_EW			# Vector#
  mu_EE <- 1#
  mu_Ef <- 0#
  MU_fZ <- 	rep(0, num_Z)	# Vector#
  MU_fW <- 	rep(0, num_W)		# Vector#
  #########################
  # Matrix covariances#
  # MU_ZW is not the same as MU_WZ because the dimensions of the matrix are not the same!#
  # Remember the covariances in rho_ZW are in the order cov(Z_1,W_1), cov(Z_1,W_2), ..., cov(Z_2,W_1),...#
  MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  MU_WZ <- t(MU_ZW)#
  MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
  MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  MU_ZZ <- sig_mat_ZZ 		# Matrix#
  MU_WW <- sig_mat_WW		# Matrix#
  #########################
  # Higher order moments#
  # We need as intermediate quantities E[G_1E], E[G_1E^2], E[G_1E^3], E[G_1G_2E], E[G_1G_2E^2], E[G1EZ], #
  # E[G1EW], E[G1EW^2], E[G1WE^2], E[G1ZE^2], E[G1G2E^2]#
  mu_G1_E <- r_GE*dnorm(w)#
  mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)#
  # E[G1G2E] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_E <- function(x,w,r_GE) {#
  	x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^2] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EE <- function(x,w,r_GE) {#
  	x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^3] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EEE <- function(x,w,r_GE) {#
  	x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # See gen_cor_bin_normal to see how to do these#
  mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GEE <- mu_Gf#
  mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  mu_GEh <- mu_GEf#
  mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  mu_GGEh <- mu_GGEf#
  ###############
  # Harder ones involving Z and W#
  # E[G1EZ] requires numerical integration#
  f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  	( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_Z <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  }#
  # E[G1EW] requires numerical integration#
  f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  	( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_W <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  }#
  # E[G1EW^2] requires numerical integration#
  f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  		sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_E_WW <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1WE^2] requires numerical integration#
  f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_W_EE <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1ZE^2] requires numerical integration#
  f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  	( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_Z_EE <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  }#
#
  # See gen_cor_bin_normal to see how to do these (vectors)#
  MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW			# Vector#
  MU_GEM <-	2*mu_G1_E_WW							# Vector#
  MU_GhW <- 2*mu_G1_W_EE#
  MU_GhZ <- 2*mu_G1_Z_EE#
  #########################
  # Some shortcut quantities#
  A <- (mu_GE * MU_GZ / mu_GG - MU_EZ) / (mu_EE - mu_GE^2/mu_GG)#
  B <- (mu_GE * MU_GW / mu_GG - MU_EW) / (mu_EE - mu_GE^2/mu_GG)#
  O <- MU_Z%*%t(MU_Z) + MU_GZ%*%t(MU_GZ)/mu_GG - MU_ZZ - A %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG)#
  C <- (B %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG) - MU_W%*%t(MU_Z) - MU_GW%*%t(MU_GZ)/mu_GG + MU_WZ) %*% solve(O)#
  Q <- MU_W%*%t(MU_W) + MU_GW%*%t(MU_GW)/mu_GG - MU_WW + B %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + #
    C %*% ( MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW + A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) )#
  D <- (mu_GE * mu_GGE / mu_GG - mu_GEE) / (mu_EE - mu_GE^2 / mu_GG)#
  E <- t(MU_GEZ - MU_Z*mu_GE - MU_GZ*mu_GGE/mu_GG + D*(MU_EZ - MU_GZ*mu_GE/mu_GG)) %*% solve(O)#
  EFF <- ( t(MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + D*(MU_GW * mu_GE / mu_GG - MU_EW)) + #
             E %*% (A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) ) %*% solve(Q)#
  # Solve for \alpha_I#
  alpha_I_num <- beta_E * (-mu_f*mu_GE - mu_Gf*mu_GGE/mu_GG + mu_GEf + D * (mu_Ef - mu_Gf*mu_GE/mu_GG)) +#
    beta_E * E %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-mu_Gf*mu_GE - mu_GGh*mu_GGE/mu_GG + mu_GGEh + D * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * E %*% (-mu_Gh*MU_Z - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    t(MU_GEM - MU_M*mu_GE - MU_GM*mu_GGE/mu_GG + D * (MU_EM - MU_GM*mu_GE/mu_GG)) %*% BETA_M + #
    E %*% (A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M - #
    beta_E * EFF %*% (-mu_f*MU_W - MU_GW*mu_Gf/mu_GG + MU_fW + B %*% as.matrix(mu_GEf - mu_GGh*mu_GE/mu_GG)) - #
    beta_E * EFF %*% C %*% (-mu_f*MU_Z - mu_Gf*MU_GZ/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) - #
    beta_I * EFF %*% (-mu_Gh*MU_W - MU_GW*mu_GGh/mu_GG + MU_GhW + B %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) -#
    beta_I * EFF %*% C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) - #
    EFF %*% ( -MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM + B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) ) %*% BETA_M - #
    EFF %*% C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M#
  alpha_I_denom <- EFF %*% ( MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) +#
    EFF %*% C %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    ( mu_GE^2 + mu_GGE^2/mu_GG - mu_GGEE + D * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    E %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) )#
  alpha_I <- alpha_I_num / alpha_I_denom#
  R <- beta_E * (-MU_W*mu_f - MU_GW*mu_Gf/mu_GG + MU_fW + B * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_E * C %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-MU_W*mu_Gh - MU_GW*mu_GGh/mu_GG + MU_GhW + B * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    ( B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM) %*% BETA_M + #
    C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    alpha_I * (MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    as.numeric(alpha_I) * C %*% (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A*(mu_GGE*mu_GE/mu_GG - mu_GEE))#
  ALPHA_W <- - solve(Q) %*% R#
  P <- beta_E * (-MU_Z*mu_f - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    alpha_I * (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    ( A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) %*% ALPHA_W#
  Bz_Az <- solve(O) %*% P#
  ALPHA_Z <- BETA_Z - solve(O) %*% P#
  alpha_E <- ( beta_E * (mu_Ef - mu_Gf*mu_GE/mu_GG) + beta_I * (mu_GEh - mu_GGh*mu_GE/mu_GG) +  #
                 alpha_I * (mu_GGE*mu_GE/mu_GG - mu_GEE) + t(MU_EZ - MU_GZ*mu_GE/mu_GG) %*% Bz_Az + #
                 t(MU_EM - MU_GM*mu_GE/mu_GG) %*% BETA_M + t(MU_GW*mu_GE/mu_GG - MU_EW) %*% ALPHA_W ) /#
    (mu_EE - mu_GE^2/mu_GG)#
  Bg_Ag <- ( alpha_E*mu_GE - beta_E*mu_Gf + alpha_I*mu_GGE - beta_I*mu_GGh - t(MU_GZ) %*% Bz_Az + #
               t(MU_GW) %*% ALPHA_W - t(MU_GM) %*% BETA_M ) / mu_GG#
  alpha_G <- beta_G - Bg_Ag#
  alpha_0 <- beta_0 + beta_E*mu_f + beta_I*mu_Gh - alpha_I*mu_GE + t(MU_Z) %*% Bz_Az +#
    t(MU_M) %*% BETA_M - t(MU_W) %*% ALPHA_W#
  # Return #
  return(list(alpha_vec=c(alpha_0, alpha_G, alpha_E, alpha_I, ALPHA_Z, ALPHA_W),#
              beta_list = c(beta_0, beta_G, beta_E, beta_I, BETA_Z, BETA_M),#
              mu_vec = c(mu_f, mu_h, MU_M),#
              cov_vec = c(mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
              mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW),#
              MU_ZZ=MU_ZZ, MU_ZM=MU_ZM, MU_ZW=MU_ZW, MU_WM=MU_WM, MU_WW=MU_WW,#
              HOM_vec = c(mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
              MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)))#
}
GE_bias_normal_squared_mis(beta_list, rho_list, prob_G, cov_Z, cov_W)
GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
solve_results$alpha_vec
sim_results
solve_results$beta_list
beta_list
#' GE_bias_normal_squaredmis.R#
#'#
#' A function to calculate the bias in testing for GxE interaction.#
#' Here we make the following assumptions:#
#' (1) All covariates (besides E) are marginally normally distributed with #
#' unit variance.  In addition, E,Z,W have mean 0.#
#' (2) G is generated by means of thresholding two independent normal RVs (jointly generated#
#' with the other covariates) and is centered to have mean 0.#
#' (3) The misspecification is of the form f(E)=h(E)=E^2, and M_j=W_j^2 for all j. In particular,#
#' W always has the same length as M here.#
#' #
#' In this version, some or all covariate terms may not exist, and some or all can be vectors.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors.#
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#' #
#' @keywords bias normal squared_misspecification#
#' @export#
#' @examples #
#' GE_bias_normal_squaredmis( beta_list=runif(n=6, min=0, max=1), rho_list=rep(0.3,1), prob_G=0.3)#
#
GE_bias_normal_squaredmis <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL)#
{#
  # Record some initial quantities#
  num_Z <- length(beta_list[[5]])#
  num_W <- length(beta_list[[6]])#
  rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  beta_0 <- beta_list[[1]]; beta_G <- beta_list[[2]]; beta_E <- beta_list[[3]]#
  beta_I <- beta_list[[4]]; BETA_Z <- beta_list[[5]]; BETA_M <- beta_list[[6]]#
#
  # Some error checking, make sure the covariance matrix is ok#
  translated_inputs <- GE_translate_inputs(beta_list, rho_list, prob_G, cov_Z, cov_W)#
  sig_mat <- translated_inputs$sig_mat_total#
  sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
  sig_mat_WW <- translated_inputs$sig_mat_WW#
  # Obvious and by assumptions#
  MU_Z <- rep(0, num_Z) 		# Some obvious ones#
  MU_M <- rep(1, num_W)		#
  MU_W <- rep(0, num_W)			#
  mu_f <- 1#
  mu_h <- 1#
  # Done translating inputs#
  # Now calculate other necessary terms that have #
  # been determined by our assumptions + inputs#
  #########################
  # Covariances#
  mu_GE <- rho_GE#
  mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
  mu_Gh <- mu_Gf#
  mu_GG <- 2*prob_G*(1-prob_G)#
  MU_GZ <- rho_GZ  	# Vector#
  MU_GW <- rho_GW		# Vector#
  MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
  MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
  MU_EZ <- rho_EZ			# Vector#
  MU_EW <- rho_EW			# Vector#
  mu_EE <- 1#
  mu_Ef <- 0#
  MU_fZ <- 	rep(0, num_Z)	# Vector#
  MU_fW <- 	rep(0, num_W)		# Vector#
  #########################
  # Matrix covariances#
  # MU_ZW is not the same as MU_WZ because the dimensions of the matrix are not the same!#
  # Remember the covariances in rho_ZW are in the order cov(Z_1,W_1), cov(Z_1,W_2), ..., cov(Z_2,W_1),...#
  MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  MU_WZ <- t(MU_ZW)#
  MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
  MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  MU_ZZ <- sig_mat_ZZ 		# Matrix#
  MU_WW <- sig_mat_WW		# Matrix#
  #########################
  # Higher order moments#
  # We need as intermediate quantities E[G_1E], E[G_1E^2], E[G_1E^3], E[G_1G_2E], E[G_1G_2E^2], E[G1EZ], #
  # E[G1EW], E[G1EW^2], E[G1WE^2], E[G1ZE^2], E[G1G2E^2]#
  mu_G1_E <- r_GE*dnorm(w)#
  mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)#
  # E[G1G2E] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_E <- function(x,w,r_GE) {#
  	x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^2] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EE <- function(x,w,r_GE) {#
  	x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^3] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EEE <- function(x,w,r_GE) {#
  	x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # See gen_cor_bin_normal to see how to do these#
  mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GEE <- mu_Gf#
  mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  mu_GEh <- mu_GEf#
  mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  mu_GGEh <- mu_GGEf#
  ###############
  # Harder ones involving Z and W#
  # E[G1EZ] requires numerical integration#
  f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  	( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_Z <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  }#
  # E[G1EW] requires numerical integration#
  f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  	( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_W <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  }#
  # E[G1EW^2] requires numerical integration#
  f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  		sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_E_WW <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1WE^2] requires numerical integration#
  f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_W_EE <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1ZE^2] requires numerical integration#
  f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  	( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_Z_EE <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  }#
#
  # See gen_cor_bin_normal to see how to do these (vectors)#
  MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW			# Vector#
  MU_GEM <-	2*mu_G1_E_WW							# Vector#
  MU_GhW <- 2*mu_G1_W_EE#
  MU_GhZ <- 2*mu_G1_Z_EE#
  #########################
  # Some shortcut quantities#
  A <- (mu_GE * MU_GZ / mu_GG - MU_EZ) / (mu_EE - mu_GE^2/mu_GG)#
  B <- (mu_GE * MU_GW / mu_GG - MU_EW) / (mu_EE - mu_GE^2/mu_GG)#
  O <- MU_Z%*%t(MU_Z) + MU_GZ%*%t(MU_GZ)/mu_GG - MU_ZZ - A %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG)#
  C <- (B %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG) - MU_W%*%t(MU_Z) - MU_GW%*%t(MU_GZ)/mu_GG + MU_WZ) %*% solve(O)#
  Q <- MU_W%*%t(MU_W) + MU_GW%*%t(MU_GW)/mu_GG - MU_WW + B %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + #
    C %*% ( MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW + A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) )#
  D <- (mu_GE * mu_GGE / mu_GG - mu_GEE) / (mu_EE - mu_GE^2 / mu_GG)#
  E <- t(MU_GEZ - MU_Z*mu_GE - MU_GZ*mu_GGE/mu_GG + D*(MU_EZ - MU_GZ*mu_GE/mu_GG)) %*% solve(O)#
  EFF <- ( t(MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + D*(MU_GW * mu_GE / mu_GG - MU_EW)) + #
             E %*% (A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) ) %*% solve(Q)#
  # Solve for \alpha_I#
  alpha_I_num <- beta_E * (-mu_f*mu_GE - mu_Gf*mu_GGE/mu_GG + mu_GEf + D * (mu_Ef - mu_Gf*mu_GE/mu_GG)) +#
    beta_E * E %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-mu_Gf*mu_GE - mu_GGh*mu_GGE/mu_GG + mu_GGEh + D * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * E %*% (-mu_Gh*MU_Z - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    t(MU_GEM - MU_M*mu_GE - MU_GM*mu_GGE/mu_GG + D * (MU_EM - MU_GM*mu_GE/mu_GG)) %*% BETA_M + #
    E %*% (A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M - #
    beta_E * EFF %*% (-mu_f*MU_W - MU_GW*mu_Gf/mu_GG + MU_fW + B %*% as.matrix(mu_GEf - mu_GGh*mu_GE/mu_GG)) - #
    beta_E * EFF %*% C %*% (-mu_f*MU_Z - mu_Gf*MU_GZ/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) - #
    beta_I * EFF %*% (-mu_Gh*MU_W - MU_GW*mu_GGh/mu_GG + MU_GhW + B %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) -#
    beta_I * EFF %*% C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) - #
    EFF %*% ( -MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM + B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) ) %*% BETA_M - #
    EFF %*% C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M#
  alpha_I_denom <- EFF %*% ( MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) +#
    EFF %*% C %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    ( mu_GE^2 + mu_GGE^2/mu_GG - mu_GGEE + D * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    E %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) )#
  alpha_I <- alpha_I_num / alpha_I_denom#
  R <- beta_E * (-MU_W*mu_f - MU_GW*mu_Gf/mu_GG + MU_fW + B * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_E * C %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-MU_W*mu_Gh - MU_GW*mu_GGh/mu_GG + MU_GhW + B * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    ( B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM) %*% BETA_M + #
    C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    alpha_I * (MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    as.numeric(alpha_I) * C %*% (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A*(mu_GGE*mu_GE/mu_GG - mu_GEE))#
  ALPHA_W <- - solve(Q) %*% R#
  P <- beta_E * (-MU_Z*mu_f - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    alpha_I * (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    ( A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) %*% ALPHA_W#
  Bz_Az <- solve(O) %*% P#
  ALPHA_Z <- BETA_Z - solve(O) %*% P#
  alpha_E <- ( beta_E * (mu_Ef - mu_Gf*mu_GE/mu_GG) + beta_I * (mu_GEh - mu_GGh*mu_GE/mu_GG) +  #
                 alpha_I * (mu_GGE*mu_GE/mu_GG - mu_GEE) + t(MU_EZ - MU_GZ*mu_GE/mu_GG) %*% Bz_Az + #
                 t(MU_EM - MU_GM*mu_GE/mu_GG) %*% BETA_M + t(MU_GW*mu_GE/mu_GG - MU_EW) %*% ALPHA_W ) /#
    (mu_EE - mu_GE^2/mu_GG)#
  Bg_Ag <- ( alpha_E*mu_GE - beta_E*mu_Gf + alpha_I*mu_GGE - beta_I*mu_GGh - t(MU_GZ) %*% Bz_Az + #
               t(MU_GW) %*% ALPHA_W - t(MU_GM) %*% BETA_M ) / mu_GG#
  alpha_G <- beta_G - Bg_Ag#
  alpha_0 <- beta_0 + beta_E*mu_f + beta_I*mu_Gh - alpha_I*mu_GE + t(MU_Z) %*% Bz_Az +#
    t(MU_M) %*% BETA_M - t(MU_W) %*% ALPHA_W#
  # Return #
  return(list(alpha_list=list(alpha_0, alpha_G, alpha_E, alpha_I, ALPHA_Z, ALPHA_W),#
              beta_list = list(beta_0, beta_G, beta_E, beta_I, BETA_Z, BETA_M),#
              mu_list = list(mu_f, mu_h, MU_M),#
              cov_list = list(mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
              mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW),#
              MU_ZZ=MU_ZZ, MU_ZM=MU_ZM, MU_ZW=MU_ZW, MU_WM=MU_WM, MU_WW=MU_WW,#
              HOM_vec = c(mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
              MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)))#
}
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
solve_results$beta_list
solve_results$mu_list
mu_list <- list( unlist(solve_results$mu_list), rep(0, num_Z), rep(0, num_W))
mu_list
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )
mu_list
#' GE_bias_normal_squaredmis.R#
#'#
#' A function to calculate the bias in testing for GxE interaction.#
#' Here we make the following assumptions:#
#' (1) All covariates (besides E) are marginally normally distributed with #
#' unit variance.  In addition, E,Z,W have mean 0.#
#' (2) G is generated by means of thresholding two independent normal RVs (jointly generated#
#' with the other covariates) and is centered to have mean 0.#
#' (3) The misspecification is of the form f(E)=h(E)=E^2, and M_j=W_j^2 for all j. In particular,#
#' W always has the same length as M here.#
#' #
#' In this version, some or all covariate terms may not exist, and some or all can be vectors.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors.#
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#' #
#' @keywords bias normal squared_misspecification#
#' @export#
#' @examples #
#' GE_bias_normal_squaredmis( beta_list=runif(n=6, min=0, max=1), rho_list=rep(0.3,1), prob_G=0.3)#
#
GE_bias_normal_squaredmis <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL)#
{#
  # Record some initial quantities#
  num_Z <- length(beta_list[[5]])#
  num_W <- length(beta_list[[6]])#
  rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  beta_0 <- beta_list[[1]]; beta_G <- beta_list[[2]]; beta_E <- beta_list[[3]]#
  beta_I <- beta_list[[4]]; BETA_Z <- beta_list[[5]]; BETA_M <- beta_list[[6]]#
#
  # Some error checking, make sure the covariance matrix is ok#
  translated_inputs <- GE_translate_inputs(beta_list, rho_list, prob_G, cov_Z, cov_W)#
  sig_mat <- translated_inputs$sig_mat_total#
  sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
  sig_mat_WW <- translated_inputs$sig_mat_WW#
  # Obvious and by assumptions#
  MU_Z <- rep(0, num_Z) 		# Some obvious ones#
  MU_M <- rep(1, num_W)		#
  MU_W <- rep(0, num_W)			#
  mu_f <- 1#
  mu_h <- 1#
  # Done translating inputs#
  # Now calculate other necessary terms that have #
  # been determined by our assumptions + inputs#
  #########################
  # Covariances#
  mu_GE <- rho_GE#
  mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
  mu_Gh <- mu_Gf#
  mu_GG <- 2*prob_G*(1-prob_G)#
  MU_GZ <- rho_GZ  	# Vector#
  MU_GW <- rho_GW		# Vector#
  MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
  MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
  MU_EZ <- rho_EZ			# Vector#
  MU_EW <- rho_EW			# Vector#
  mu_EE <- 1#
  mu_Ef <- 0#
  MU_fZ <- 	rep(0, num_Z)	# Vector#
  MU_fW <- 	rep(0, num_W)		# Vector#
  #########################
  # Matrix covariances#
  # MU_ZW is not the same as MU_WZ because the dimensions of the matrix are not the same!#
  # Remember the covariances in rho_ZW are in the order cov(Z_1,W_1), cov(Z_1,W_2), ..., cov(Z_2,W_1),...#
  MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  MU_WZ <- t(MU_ZW)#
  MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
  MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  MU_ZZ <- sig_mat_ZZ 		# Matrix#
  MU_WW <- sig_mat_WW		# Matrix#
  #########################
  # Higher order moments#
  # We need as intermediate quantities E[G_1E], E[G_1E^2], E[G_1E^3], E[G_1G_2E], E[G_1G_2E^2], E[G1EZ], #
  # E[G1EW], E[G1EW^2], E[G1WE^2], E[G1ZE^2], E[G1G2E^2]#
  mu_G1_E <- r_GE*dnorm(w)#
  mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)#
  # E[G1G2E] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_E <- function(x,w,r_GE) {#
  	x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^2] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EE <- function(x,w,r_GE) {#
  	x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^3] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EEE <- function(x,w,r_GE) {#
  	x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # See gen_cor_bin_normal to see how to do these#
  mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GEE <- mu_Gf#
  mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  mu_GEh <- mu_GEf#
  mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  mu_GGEh <- mu_GGEf#
  ###############
  # Harder ones involving Z and W#
  # E[G1EZ] requires numerical integration#
  f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  	( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_Z <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  }#
  # E[G1EW] requires numerical integration#
  f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  	( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_W <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  }#
  # E[G1EW^2] requires numerical integration#
  f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  		sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_E_WW <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1WE^2] requires numerical integration#
  f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_W_EE <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1ZE^2] requires numerical integration#
  f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  	( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_Z_EE <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  }#
#
  # See gen_cor_bin_normal to see how to do these (vectors)#
  MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW			# Vector#
  MU_GEM <-	2*mu_G1_E_WW							# Vector#
  MU_GhW <- 2*mu_G1_W_EE#
  MU_GhZ <- 2*mu_G1_Z_EE#
  #########################
  # Some shortcut quantities#
  A <- (mu_GE * MU_GZ / mu_GG - MU_EZ) / (mu_EE - mu_GE^2/mu_GG)#
  B <- (mu_GE * MU_GW / mu_GG - MU_EW) / (mu_EE - mu_GE^2/mu_GG)#
  O <- MU_Z%*%t(MU_Z) + MU_GZ%*%t(MU_GZ)/mu_GG - MU_ZZ - A %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG)#
  C <- (B %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG) - MU_W%*%t(MU_Z) - MU_GW%*%t(MU_GZ)/mu_GG + MU_WZ) %*% solve(O)#
  Q <- MU_W%*%t(MU_W) + MU_GW%*%t(MU_GW)/mu_GG - MU_WW + B %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + #
    C %*% ( MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW + A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) )#
  D <- (mu_GE * mu_GGE / mu_GG - mu_GEE) / (mu_EE - mu_GE^2 / mu_GG)#
  E <- t(MU_GEZ - MU_Z*mu_GE - MU_GZ*mu_GGE/mu_GG + D*(MU_EZ - MU_GZ*mu_GE/mu_GG)) %*% solve(O)#
  EFF <- ( t(MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + D*(MU_GW * mu_GE / mu_GG - MU_EW)) + #
             E %*% (A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) ) %*% solve(Q)#
  # Solve for \alpha_I#
  alpha_I_num <- beta_E * (-mu_f*mu_GE - mu_Gf*mu_GGE/mu_GG + mu_GEf + D * (mu_Ef - mu_Gf*mu_GE/mu_GG)) +#
    beta_E * E %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-mu_Gf*mu_GE - mu_GGh*mu_GGE/mu_GG + mu_GGEh + D * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * E %*% (-mu_Gh*MU_Z - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    t(MU_GEM - MU_M*mu_GE - MU_GM*mu_GGE/mu_GG + D * (MU_EM - MU_GM*mu_GE/mu_GG)) %*% BETA_M + #
    E %*% (A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M - #
    beta_E * EFF %*% (-mu_f*MU_W - MU_GW*mu_Gf/mu_GG + MU_fW + B %*% as.matrix(mu_GEf - mu_GGh*mu_GE/mu_GG)) - #
    beta_E * EFF %*% C %*% (-mu_f*MU_Z - mu_Gf*MU_GZ/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) - #
    beta_I * EFF %*% (-mu_Gh*MU_W - MU_GW*mu_GGh/mu_GG + MU_GhW + B %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) -#
    beta_I * EFF %*% C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) - #
    EFF %*% ( -MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM + B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) ) %*% BETA_M - #
    EFF %*% C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M#
  alpha_I_denom <- EFF %*% ( MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) +#
    EFF %*% C %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    ( mu_GE^2 + mu_GGE^2/mu_GG - mu_GGEE + D * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    E %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) )#
  alpha_I <- alpha_I_num / alpha_I_denom#
  R <- beta_E * (-MU_W*mu_f - MU_GW*mu_Gf/mu_GG + MU_fW + B * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_E * C %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-MU_W*mu_Gh - MU_GW*mu_GGh/mu_GG + MU_GhW + B * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    ( B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM) %*% BETA_M + #
    C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    alpha_I * (MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    as.numeric(alpha_I) * C %*% (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A*(mu_GGE*mu_GE/mu_GG - mu_GEE))#
  ALPHA_W <- - solve(Q) %*% R#
  P <- beta_E * (-MU_Z*mu_f - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    alpha_I * (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    ( A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) %*% ALPHA_W#
  Bz_Az <- solve(O) %*% P#
  ALPHA_Z <- BETA_Z - solve(O) %*% P#
  alpha_E <- ( beta_E * (mu_Ef - mu_Gf*mu_GE/mu_GG) + beta_I * (mu_GEh - mu_GGh*mu_GE/mu_GG) +  #
                 alpha_I * (mu_GGE*mu_GE/mu_GG - mu_GEE) + t(MU_EZ - MU_GZ*mu_GE/mu_GG) %*% Bz_Az + #
                 t(MU_EM - MU_GM*mu_GE/mu_GG) %*% BETA_M + t(MU_GW*mu_GE/mu_GG - MU_EW) %*% ALPHA_W ) /#
    (mu_EE - mu_GE^2/mu_GG)#
  Bg_Ag <- ( alpha_E*mu_GE - beta_E*mu_Gf + alpha_I*mu_GGE - beta_I*mu_GGh - t(MU_GZ) %*% Bz_Az + #
               t(MU_GW) %*% ALPHA_W - t(MU_GM) %*% BETA_M ) / mu_GG#
  alpha_G <- beta_G - Bg_Ag#
  alpha_0 <- beta_0 + beta_E*mu_f + beta_I*mu_Gh - alpha_I*mu_GE + t(MU_Z) %*% Bz_Az +#
    t(MU_M) %*% BETA_M - t(MU_W) %*% ALPHA_W#
  # Return #
  return(list(alpha_list=list(alpha_0, alpha_G, alpha_E, alpha_I, ALPHA_Z, ALPHA_W),#
              beta_list = list(beta_0, beta_G, beta_E, beta_I, BETA_Z, BETA_M),#
              mu_list = list(mu_f, mu_h, MU_M),#
              cov_list = list(mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
              mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW),#
              MU_ZZ=MU_ZZ, MU_ZM=MU_ZM, MU_ZW=MU_ZW, MU_WM=MU_WM, MU_WW=MU_WW,#
              HOM_list = c(mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
              MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)))#
}
#' GE_bias_normal_squaredmis.R#
#'#
#' A function to calculate the bias in testing for GxE interaction.#
#' Here we make the following assumptions:#
#' (1) All covariates (besides E) are marginally normally distributed with #
#' unit variance.  In addition, E,Z,W have mean 0.#
#' (2) G is generated by means of thresholding two independent normal RVs (jointly generated#
#' with the other covariates) and is centered to have mean 0.#
#' (3) The misspecification is of the form f(E)=h(E)=E^2, and M_j=W_j^2 for all j. In particular,#
#' W always has the same length as M here.#
#' #
#' In this version, some or all covariate terms may not exist, and some or all can be vectors.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors.#
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#' #
#' @keywords bias normal squared_misspecification#
#' @export#
#' @examples #
#' GE_bias_normal_squaredmis( beta_list=runif(n=6, min=0, max=1), rho_list=rep(0.3,1), prob_G=0.3)#
#
GE_bias_normal_squaredmis <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL)#
{#
  # Record some initial quantities#
  num_Z <- length(beta_list[[5]])#
  num_W <- length(beta_list[[6]])#
  rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  beta_0 <- beta_list[[1]]; beta_G <- beta_list[[2]]; beta_E <- beta_list[[3]]#
  beta_I <- beta_list[[4]]; BETA_Z <- beta_list[[5]]; BETA_M <- beta_list[[6]]#
#
  # Some error checking, make sure the covariance matrix is ok#
  translated_inputs <- GE_translate_inputs(beta_list, rho_list, prob_G, cov_Z, cov_W)#
  sig_mat <- translated_inputs$sig_mat_total#
  sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
  sig_mat_WW <- translated_inputs$sig_mat_WW#
  # Obvious and by assumptions#
  MU_Z <- rep(0, num_Z) 		# Some obvious ones#
  MU_M <- rep(1, num_W)		#
  MU_W <- rep(0, num_W)			#
  mu_f <- 1#
  mu_h <- 1#
  # Done translating inputs#
  # Now calculate other necessary terms that have #
  # been determined by our assumptions + inputs#
  #########################
  # Covariances#
  mu_GE <- rho_GE#
  mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
  mu_Gh <- mu_Gf#
  mu_GG <- 2*prob_G*(1-prob_G)#
  MU_GZ <- rho_GZ  	# Vector#
  MU_GW <- rho_GW		# Vector#
  MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
  MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
  MU_EZ <- rho_EZ			# Vector#
  MU_EW <- rho_EW			# Vector#
  mu_EE <- 1#
  mu_Ef <- 0#
  MU_fZ <- 	rep(0, num_Z)	# Vector#
  MU_fW <- 	rep(0, num_W)		# Vector#
  #########################
  # Matrix covariances#
  # MU_ZW is not the same as MU_WZ because the dimensions of the matrix are not the same!#
  # Remember the covariances in rho_ZW are in the order cov(Z_1,W_1), cov(Z_1,W_2), ..., cov(Z_2,W_1),...#
  MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  MU_WZ <- t(MU_ZW)#
  MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
  MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  MU_ZZ <- sig_mat_ZZ 		# Matrix#
  MU_WW <- sig_mat_WW		# Matrix#
  #########################
  # Higher order moments#
  # We need as intermediate quantities E[G_1E], E[G_1E^2], E[G_1E^3], E[G_1G_2E], E[G_1G_2E^2], E[G1EZ], #
  # E[G1EW], E[G1EW^2], E[G1WE^2], E[G1ZE^2], E[G1G2E^2]#
  mu_G1_E <- r_GE*dnorm(w)#
  mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)#
  # E[G1G2E] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_E <- function(x,w,r_GE) {#
  	x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^2] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EE <- function(x,w,r_GE) {#
  	x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^3] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EEE <- function(x,w,r_GE) {#
  	x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # See gen_cor_bin_normal to see how to do these#
  mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GEE <- mu_Gf#
  mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  mu_GEh <- mu_GEf#
  mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  mu_GGEh <- mu_GGEf#
  ###############
  # Harder ones involving Z and W#
  # E[G1EZ] requires numerical integration#
  f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  	( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_Z <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  }#
  # E[G1EW] requires numerical integration#
  f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  	( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_W <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  }#
  # E[G1EW^2] requires numerical integration#
  f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  		sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_E_WW <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1WE^2] requires numerical integration#
  f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_W_EE <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1ZE^2] requires numerical integration#
  f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  	( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_Z_EE <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  }#
#
  # See gen_cor_bin_normal to see how to do these (vectors)#
  MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW			# Vector#
  MU_GEM <-	2*mu_G1_E_WW							# Vector#
  MU_GhW <- 2*mu_G1_W_EE#
  MU_GhZ <- 2*mu_G1_Z_EE#
  #########################
  # Some shortcut quantities#
  A <- (mu_GE * MU_GZ / mu_GG - MU_EZ) / (mu_EE - mu_GE^2/mu_GG)#
  B <- (mu_GE * MU_GW / mu_GG - MU_EW) / (mu_EE - mu_GE^2/mu_GG)#
  O <- MU_Z%*%t(MU_Z) + MU_GZ%*%t(MU_GZ)/mu_GG - MU_ZZ - A %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG)#
  C <- (B %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG) - MU_W%*%t(MU_Z) - MU_GW%*%t(MU_GZ)/mu_GG + MU_WZ) %*% solve(O)#
  Q <- MU_W%*%t(MU_W) + MU_GW%*%t(MU_GW)/mu_GG - MU_WW + B %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + #
    C %*% ( MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW + A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) )#
  D <- (mu_GE * mu_GGE / mu_GG - mu_GEE) / (mu_EE - mu_GE^2 / mu_GG)#
  E <- t(MU_GEZ - MU_Z*mu_GE - MU_GZ*mu_GGE/mu_GG + D*(MU_EZ - MU_GZ*mu_GE/mu_GG)) %*% solve(O)#
  EFF <- ( t(MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + D*(MU_GW * mu_GE / mu_GG - MU_EW)) + #
             E %*% (A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) ) %*% solve(Q)#
  # Solve for \alpha_I#
  alpha_I_num <- beta_E * (-mu_f*mu_GE - mu_Gf*mu_GGE/mu_GG + mu_GEf + D * (mu_Ef - mu_Gf*mu_GE/mu_GG)) +#
    beta_E * E %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-mu_Gf*mu_GE - mu_GGh*mu_GGE/mu_GG + mu_GGEh + D * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * E %*% (-mu_Gh*MU_Z - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    t(MU_GEM - MU_M*mu_GE - MU_GM*mu_GGE/mu_GG + D * (MU_EM - MU_GM*mu_GE/mu_GG)) %*% BETA_M + #
    E %*% (A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M - #
    beta_E * EFF %*% (-mu_f*MU_W - MU_GW*mu_Gf/mu_GG + MU_fW + B %*% as.matrix(mu_GEf - mu_GGh*mu_GE/mu_GG)) - #
    beta_E * EFF %*% C %*% (-mu_f*MU_Z - mu_Gf*MU_GZ/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) - #
    beta_I * EFF %*% (-mu_Gh*MU_W - MU_GW*mu_GGh/mu_GG + MU_GhW + B %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) -#
    beta_I * EFF %*% C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) - #
    EFF %*% ( -MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM + B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) ) %*% BETA_M - #
    EFF %*% C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M#
  alpha_I_denom <- EFF %*% ( MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) +#
    EFF %*% C %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    ( mu_GE^2 + mu_GGE^2/mu_GG - mu_GGEE + D * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    E %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) )#
  alpha_I <- alpha_I_num / alpha_I_denom#
  R <- beta_E * (-MU_W*mu_f - MU_GW*mu_Gf/mu_GG + MU_fW + B * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_E * C %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-MU_W*mu_Gh - MU_GW*mu_GGh/mu_GG + MU_GhW + B * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    ( B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM) %*% BETA_M + #
    C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    alpha_I * (MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    as.numeric(alpha_I) * C %*% (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A*(mu_GGE*mu_GE/mu_GG - mu_GEE))#
  ALPHA_W <- - solve(Q) %*% R#
  P <- beta_E * (-MU_Z*mu_f - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    alpha_I * (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    ( A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) %*% ALPHA_W#
  Bz_Az <- solve(O) %*% P#
  ALPHA_Z <- BETA_Z - solve(O) %*% P#
  alpha_E <- ( beta_E * (mu_Ef - mu_Gf*mu_GE/mu_GG) + beta_I * (mu_GEh - mu_GGh*mu_GE/mu_GG) +  #
                 alpha_I * (mu_GGE*mu_GE/mu_GG - mu_GEE) + t(MU_EZ - MU_GZ*mu_GE/mu_GG) %*% Bz_Az + #
                 t(MU_EM - MU_GM*mu_GE/mu_GG) %*% BETA_M + t(MU_GW*mu_GE/mu_GG - MU_EW) %*% ALPHA_W ) /#
    (mu_EE - mu_GE^2/mu_GG)#
  Bg_Ag <- ( alpha_E*mu_GE - beta_E*mu_Gf + alpha_I*mu_GGE - beta_I*mu_GGh - t(MU_GZ) %*% Bz_Az + #
               t(MU_GW) %*% ALPHA_W - t(MU_GM) %*% BETA_M ) / mu_GG#
  alpha_G <- beta_G - Bg_Ag#
  alpha_0 <- beta_0 + beta_E*mu_f + beta_I*mu_Gh - alpha_I*mu_GE + t(MU_Z) %*% Bz_Az +#
    t(MU_M) %*% BETA_M - t(MU_W) %*% ALPHA_W#
  # Return #
  return(list(alpha_list=list(alpha_0, alpha_G, alpha_E, alpha_I, ALPHA_Z, ALPHA_W),#
              beta_list = list(beta_0, beta_G, beta_E, beta_I, BETA_Z, BETA_M),#
              mu_list = list(mu_f, mu_h, MU_M),#
              cov_list = list(mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
              mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW),#
              MU_ZZ=MU_ZZ, MU_ZM=MU_ZM, MU_ZW=MU_ZW, MU_WM=MU_WM, MU_WW=MU_WW,#
              HOM_list = list(mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
              MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)))#
}
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)#
#
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )#
#
cov_list <- solve_results$cov_list#
#
HOM_list <- solve_results$HOM_list
cov_list
HOM_list
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )#
#
cov_list <- solve_results$cov_list#
HOM_list <- solve_results$HOM_list#
#
GE_nleqslv(beta_list, mu_list, cov_list, solve_results$MU_ZZ, solve_results$MU_ZM,#
		solve_results$MU_ZW, solve_results$MU_WM, solve_results$MU_WW, HOM_list)
#' GE_nleqslv#
#'#
#' Deprecated version as of Sep 27, 2016.  Designed only to work with scalar Z and W/M.#
#'#
#' Here we use the package nleqslv to get a numerical solution which#
#' we can use to check our direct solution.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' @param mu_list A list of the means for f, h, M, Z, W in that order.#
#' @param cov_list A list of the covariances in the order#
#' (mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
#' mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW)#
#' @param MU_ZZ Matrix mean#
#' @param MU_ZM Matrix mean#
#' @param MU_ZW Matrix mean#
#' @param MU_WZ Matrix mean#
#' @param MU_WM Matrix mean#
#' @param MU_WW Matrix mean#
#' @param HOM_list A vector of the higher order moments in the order#
#' (mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
#' MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)#
#'#
#' @keywords nonlinear equation#
#' @export#
#' @examples #
#' GE_bias_results <- GE_bias_normal_squaredmis(runif(6), runif(3), runif(10))#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_list, GE_bias_results$cov_list,#
#' GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW, GE_bias_results$MU_WZ,#
#' GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_list)#
#
GE_nleqslv <- function(beta_list, mu_list, cov_list, MU_ZZ, MU_ZM, MU_ZW, MU_WM, MU_WW, HOM_list)#
{#
#
	# Here we extract the relevant parameters from the inputs#
	beta_0 <- beta_list[[1]]#
	beta_G <- beta_list[[2]]#
	beta_E <- beta_list[[3]]#
	beta_I <- beta_list[[4]]#
	BETA_Z <- beta_list[[5]]#
	BETA_M <- beta_list[[6]]#
#
	mu_f <- mu_list[[1]]#
	mu_h <- mu_list[[2]]#
	MU_M <- mu_list[[3]]#
	MU_Z <- mu_list[[4]]#
	MU_W <- mu_list[[5]]#
	num_Z <- length(BETA_Z)#
	num_W <- length(MU_W)#
	mu_GG <- cov_list[[1]]#
	mu_GE <- cov_list[[2]]#
	mu_Gf <- cov_list[[3]]#
	mu_Gh <- cov_list[[4]]#
	MU_GZ <- cov_list[[5]]#
	MU_GM <- cov_list[[6]]#
	MU_GW <- cov_list[[7]]#
	mu_EE <- cov_list[[8]]#
	mu_Ef <- cov_list[[9]]#
	MU_EZ <- cov_list[[10]]#
	MU_EM <- cov_list[[11]]#
	MU_EW <- cov_list[[12]]#
	MU_fZ <- cov_list[[13]]#
	MU_fW <- cov_list[[14]]#
	mu_GGE <- HOM_list[[1]]#
	mu_GGh <- HOM_list[[2]]#
	mu_GEE <- HOM_list[[3]]#
	mu_GEf <- HOM_list[[4]]#
	mu_GEh <- HOM_list[[5]]#
	MU_GEZ <- HOM_list[[6]]#
	MU_GEM <- HOM_list[[7]]#
	MU_GEW <- HOM_list[[8]]#
	MU_GhW <- HOM_list[[9]]#
	MU_GhZ <- HOM_list[[10]]#
	mu_GGEE <- HOM_list[[11]]#
	mu_GGEf <- HOM_list[[12]]#
	mu_GGEh <- HOM_list[[13]]#
	#################################################################			#
	# Define the set of score equations we will be solving#
	score_eqs <- function(x)#
	{#
		alpha_0 <- x[1]#
		alpha_G <- x[2]#
		alpha_E <- x[3]#
		alpha_I <- x[4]#
		ALPHA_Z <- x[5:4+num_Z]#
		ALPHA_W <- x[(5+num_Z):(4+num_Z+num_W)]#
		y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M#
		y[2] = alpha_G*mu_GG + alpha_E*mu_GE + alpha_I*mu_GGE + t(MU_GZ) %*% ALPHA_Z + t(MU_GW) %*% ALPHA_W - #
			beta_G*mu_GG - beta_E*mu_Gf - beta_I*mu_GGh - t(MU_GZ) %*% BETA_Z - t(MU_GM) %*% BETA_M#
		y[3] = alpha_G*mu_GE + alpha_E*mu_EE + alpha_I*mu_GEE + t(MU_EZ) %*% ALPHA_Z + t(MU_EW) %*% ALPHA_W - #
			beta_G*mu_GE - beta_E*mu_Ef - beta_I*mu_GEh - t(MU_EZ) %*% BETA_Z - t(MU_EM) %*% BETA_M#
		y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M#
		y[5] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M#
		y[6] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_ZW %*% BETA_Z - MU_WM %*% BETA_M#
		y#
	}#
	solved_scoreeqs = nleqslv::nleqslv(x=c(0,0,0,0, rep(0, (num_Z+num_W)), fn=score_eqs)#
	return(solved_scoreeqs)#
}
#' GE_nleqslv#
#'#
#' Deprecated version as of Sep 27, 2016.  Designed only to work with scalar Z and W/M.#
#'#
#' Here we use the package nleqslv to get a numerical solution which#
#' we can use to check our direct solution.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' @param mu_list A list of the means for f, h, M, Z, W in that order.#
#' @param cov_list A list of the covariances in the order#
#' (mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
#' mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW)#
#' @param MU_ZZ Matrix mean#
#' @param MU_ZM Matrix mean#
#' @param MU_ZW Matrix mean#
#' @param MU_WZ Matrix mean#
#' @param MU_WM Matrix mean#
#' @param MU_WW Matrix mean#
#' @param HOM_list A vector of the higher order moments in the order#
#' (mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
#' MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)#
#'#
#' @keywords nonlinear equation#
#' @export#
#' @examples #
#' GE_bias_results <- GE_bias_normal_squaredmis(runif(6), runif(3), runif(10))#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_list, GE_bias_results$cov_list,#
#' GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW, GE_bias_results$MU_WZ,#
#' GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_list)#
#
GE_nleqslv <- function(beta_list, mu_list, cov_list, MU_ZZ, MU_ZM, MU_ZW, MU_WM, MU_WW, HOM_list)#
{#
#
	# Here we extract the relevant parameters from the inputs#
	beta_0 <- beta_list[[1]]#
	beta_G <- beta_list[[2]]#
	beta_E <- beta_list[[3]]#
	beta_I <- beta_list[[4]]#
	BETA_Z <- beta_list[[5]]#
	BETA_M <- beta_list[[6]]#
#
	mu_f <- mu_list[[1]]#
	mu_h <- mu_list[[2]]#
	MU_M <- mu_list[[3]]#
	MU_Z <- mu_list[[4]]#
	MU_W <- mu_list[[5]]#
	num_Z <- length(BETA_Z)#
	num_W <- length(MU_W)#
	mu_GG <- cov_list[[1]]#
	mu_GE <- cov_list[[2]]#
	mu_Gf <- cov_list[[3]]#
	mu_Gh <- cov_list[[4]]#
	MU_GZ <- cov_list[[5]]#
	MU_GM <- cov_list[[6]]#
	MU_GW <- cov_list[[7]]#
	mu_EE <- cov_list[[8]]#
	mu_Ef <- cov_list[[9]]#
	MU_EZ <- cov_list[[10]]#
	MU_EM <- cov_list[[11]]#
	MU_EW <- cov_list[[12]]#
	MU_fZ <- cov_list[[13]]#
	MU_fW <- cov_list[[14]]#
	mu_GGE <- HOM_list[[1]]#
	mu_GGh <- HOM_list[[2]]#
	mu_GEE <- HOM_list[[3]]#
	mu_GEf <- HOM_list[[4]]#
	mu_GEh <- HOM_list[[5]]#
	MU_GEZ <- HOM_list[[6]]#
	MU_GEM <- HOM_list[[7]]#
	MU_GEW <- HOM_list[[8]]#
	MU_GhW <- HOM_list[[9]]#
	MU_GhZ <- HOM_list[[10]]#
	mu_GGEE <- HOM_list[[11]]#
	mu_GGEf <- HOM_list[[12]]#
	mu_GGEh <- HOM_list[[13]]#
	#################################################################			#
	# Define the set of score equations we will be solving#
	score_eqs <- function(x)#
	{#
		alpha_0 <- x[1]#
		alpha_G <- x[2]#
		alpha_E <- x[3]#
		alpha_I <- x[4]#
		ALPHA_Z <- x[5:4+num_Z]#
		ALPHA_W <- x[(5+num_Z):(4+num_Z+num_W)]#
		y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M#
		y[2] = alpha_G*mu_GG + alpha_E*mu_GE + alpha_I*mu_GGE + t(MU_GZ) %*% ALPHA_Z + t(MU_GW) %*% ALPHA_W - #
			beta_G*mu_GG - beta_E*mu_Gf - beta_I*mu_GGh - t(MU_GZ) %*% BETA_Z - t(MU_GM) %*% BETA_M#
		y[3] = alpha_G*mu_GE + alpha_E*mu_EE + alpha_I*mu_GEE + t(MU_EZ) %*% ALPHA_Z + t(MU_EW) %*% ALPHA_W - #
			beta_G*mu_GE - beta_E*mu_Ef - beta_I*mu_GEh - t(MU_EZ) %*% BETA_Z - t(MU_EM) %*% BETA_M#
		y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M#
		y[5] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M#
		y[6] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_ZW %*% BETA_Z - MU_WM %*% BETA_M#
		y#
	}#
	solved_scoreeqs = nleqslv::nleqslv(x=c(0,0,0,0, rep(0, (num_Z+num_W))), fn=score_eqs)#
	return(solved_scoreeqs)#
}
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )#
#
cov_list <- solve_results$cov_list#
HOM_list <- solve_results$HOM_list#
#
GE_nleqslv(beta_list, mu_list, cov_list, solve_results$MU_ZZ, solve_results$MU_ZM,#
		solve_results$MU_ZW, solve_results$MU_WM, solve_results$MU_WW, HOM_list)
#' GE_nleqslv#
#'#
#' Deprecated version as of Sep 27, 2016.  Designed only to work with scalar Z and W/M.#
#'#
#' Here we use the package nleqslv to get a numerical solution which#
#' we can use to check our direct solution.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' @param mu_list A list of the means for f, h, M, Z, W in that order.#
#' @param cov_list A list of the covariances in the order#
#' (mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
#' mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW)#
#' @param MU_ZZ Matrix mean#
#' @param MU_ZM Matrix mean#
#' @param MU_ZW Matrix mean#
#' @param MU_WZ Matrix mean#
#' @param MU_WM Matrix mean#
#' @param MU_WW Matrix mean#
#' @param HOM_list A vector of the higher order moments in the order#
#' (mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
#' MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)#
#'#
#' @keywords nonlinear equation#
#' @export#
#' @examples #
#' GE_bias_results <- GE_bias_normal_squaredmis(runif(6), runif(3), runif(10))#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_list, GE_bias_results$cov_list,#
#' GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW, GE_bias_results$MU_WZ,#
#' GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_list)#
#
GE_nleqslv <- function(beta_list, mu_list, cov_list, MU_ZZ, MU_ZM, MU_ZW, MU_WM, MU_WW, HOM_list)#
{#
#
	# Here we extract the relevant parameters from the inputs#
	beta_0 <- beta_list[[1]]#
	beta_G <- beta_list[[2]]#
	beta_E <- beta_list[[3]]#
	beta_I <- beta_list[[4]]#
	BETA_Z <- beta_list[[5]]#
	BETA_M <- beta_list[[6]]#
#
	mu_f <- mu_list[[1]]#
	mu_h <- mu_list[[2]]#
	MU_M <- mu_list[[3]]#
	MU_Z <- mu_list[[4]]#
	MU_W <- mu_list[[5]]#
	num_Z <- length(BETA_Z)#
	num_W <- length(MU_W)#
	mu_GG <- cov_list[[1]]#
	mu_GE <- cov_list[[2]]#
	mu_Gf <- cov_list[[3]]#
	mu_Gh <- cov_list[[4]]#
	MU_GZ <- cov_list[[5]]#
	MU_GM <- cov_list[[6]]#
	MU_GW <- cov_list[[7]]#
	mu_EE <- cov_list[[8]]#
	mu_Ef <- cov_list[[9]]#
	MU_EZ <- cov_list[[10]]#
	MU_EM <- cov_list[[11]]#
	MU_EW <- cov_list[[12]]#
	MU_fZ <- cov_list[[13]]#
	MU_fW <- cov_list[[14]]#
	mu_GGE <- HOM_list[[1]]#
	mu_GGh <- HOM_list[[2]]#
	mu_GEE <- HOM_list[[3]]#
	mu_GEf <- HOM_list[[4]]#
	mu_GEh <- HOM_list[[5]]#
	MU_GEZ <- HOM_list[[6]]#
	MU_GEM <- HOM_list[[7]]#
	MU_GEW <- HOM_list[[8]]#
	MU_GhW <- HOM_list[[9]]#
	MU_GhZ <- HOM_list[[10]]#
	mu_GGEE <- HOM_list[[11]]#
	mu_GGEf <- HOM_list[[12]]#
	mu_GGEh <- HOM_list[[13]]#
	#################################################################			#
	# Define the set of score equations we will be solving#
	score_eqs <- function(x)#
	{#
		alpha_0 <- x[1]#
		alpha_G <- x[2]#
		alpha_E <- x[3]#
		alpha_I <- x[4]#
		ALPHA_Z <- x[5:(4+num_Z)]#
		ALPHA_W <- x[(5+num_Z):(4+num_Z+num_W)]#
		y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M#
		y[2] = alpha_G*mu_GG + alpha_E*mu_GE + alpha_I*mu_GGE + t(MU_GZ) %*% ALPHA_Z + t(MU_GW) %*% ALPHA_W - #
			beta_G*mu_GG - beta_E*mu_Gf - beta_I*mu_GGh - t(MU_GZ) %*% BETA_Z - t(MU_GM) %*% BETA_M#
		y[3] = alpha_G*mu_GE + alpha_E*mu_EE + alpha_I*mu_GEE + t(MU_EZ) %*% ALPHA_Z + t(MU_EW) %*% ALPHA_W - #
			beta_G*mu_GE - beta_E*mu_Ef - beta_I*mu_GEh - t(MU_EZ) %*% BETA_Z - t(MU_EM) %*% BETA_M#
		y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M#
		y[5:(4+num_Z)] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M#
		y[(5+num_Z):(4+num_Z+num_W)] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_ZW %*% BETA_Z - MU_WM %*% BETA_M#
		y#
	}#
	solved_scoreeqs = nleqslv::nleqslv(x=c(0,0,0,0, rep(0, (num_Z+num_W))), fn=score_eqs)#
	return(solved_scoreeqs)#
}
GE_nleqslv(beta_list, mu_list, cov_list, solve_results$MU_ZZ, solve_results$MU_ZM,#
		solve_results$MU_ZW, solve_results$MU_WM, solve_results$MU_WW, HOM_list)
beta_0 <- beta_list[[1]]#
	beta_G <- beta_list[[2]]#
	beta_E <- beta_list[[3]]#
	beta_I <- beta_list[[4]]#
	BETA_Z <- beta_list[[5]]#
	BETA_M <- beta_list[[6]]#
#
	mu_f <- mu_list[[1]]#
	mu_h <- mu_list[[2]]#
	MU_M <- mu_list[[3]]#
	MU_Z <- mu_list[[4]]#
	MU_W <- mu_list[[5]]#
	num_Z <- length(BETA_Z)#
	num_W <- length(MU_W)#
	mu_GG <- cov_list[[1]]#
	mu_GE <- cov_list[[2]]#
	mu_Gf <- cov_list[[3]]#
	mu_Gh <- cov_list[[4]]#
	MU_GZ <- cov_list[[5]]#
	MU_GM <- cov_list[[6]]#
	MU_GW <- cov_list[[7]]#
	mu_EE <- cov_list[[8]]#
	mu_Ef <- cov_list[[9]]#
	MU_EZ <- cov_list[[10]]#
	MU_EM <- cov_list[[11]]#
	MU_EW <- cov_list[[12]]#
	MU_fZ <- cov_list[[13]]#
	MU_fW <- cov_list[[14]]#
	mu_GGE <- HOM_list[[1]]#
	mu_GGh <- HOM_list[[2]]#
	mu_GEE <- HOM_list[[3]]#
	mu_GEf <- HOM_list[[4]]#
	mu_GEh <- HOM_list[[5]]#
	MU_GEZ <- HOM_list[[6]]#
	MU_GEM <- HOM_list[[7]]#
	MU_GEW <- HOM_list[[8]]#
	MU_GhW <- HOM_list[[9]]#
	MU_GhZ <- HOM_list[[10]]#
	mu_GGEE <- HOM_list[[11]]#
	mu_GGEf <- HOM_list[[12]]#
	mu_GGEh <- HOM_list[[13]]
num_Z
num_W
x <- rep(0,)
x <- rep(0,7)
alpha_0 <- x[1]#
		alpha_G <- x[2]#
		alpha_E <- x[3]#
		alpha_I <- x[4]#
		ALPHA_Z <- x[5:(4+num_Z)]#
		ALPHA_W <- x[(5+num_Z):(4+num_Z+num_W)]#
		y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M
alpha_0
alpha_G
alpha_E
alpha_I
alpha_Z
ALPHA_Z
ALPHA_W
y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M#
		y[2] = alpha_G*mu_GG + alpha_E*mu_GE + alpha_I*mu_GGE + t(MU_GZ) %*% ALPHA_Z + t(MU_GW) %*% ALPHA_W - #
			beta_G*mu_GG - beta_E*mu_Gf - beta_I*mu_GGh - t(MU_GZ) %*% BETA_Z - t(MU_GM) %*% BETA_M#
		y[3] = alpha_G*mu_GE + alpha_E*mu_EE + alpha_I*mu_GEE + t(MU_EZ) %*% ALPHA_Z + t(MU_EW) %*% ALPHA_W - #
			beta_G*mu_GE - beta_E*mu_Ef - beta_I*mu_GEh - t(MU_EZ) %*% BETA_Z - t(MU_EM) %*% BETA_M#
		y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M
y[5:(4+num_Z)] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M#
		y[(5+num_Z):(4+num_Z+num_W)] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_ZW %*% BETA_Z - MU_WM %*% BETA_M
MU_ZW
ALPHA_W
solve_results$MU_ZW
MU_ZW = solve_results$MU_ZW
MU_ZZ=solve_results$MU_ZZ
MU_ZM=solve_results$MU_ZM
MU_ZWsolve_results$MU_ZW
MU_ZW=solve_results$MU_ZW
MU_WM=solve_results$MU_WM
MU_WW=solve_results$MU_WW
y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M
y[5:(4+num_Z)] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M
y[(5+num_Z):(4+num_Z+num_W)] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_ZW %*% BETA_Z - MU_WM %*% BETA_M
alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z +
0
MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_ZW %*% BETA_Z - MU_WM %*% BETA_M
MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW
MU_ZW %*% BETA_Z - MU_WM %*% BETA_M
MU_ZW
BETA_Z
MU_WM
BETA_M
MU_ZW %*% BETA_Z - MU_WM %*% BETA_M
MU_ZW %*% BETA_Z
MU_ZW=solve_results$MU_ZW
solve_results$MU_ZW
BETA_Z
MU_ZW %*% BETA_Z
MU_WZ
MU_WZ=solve_results$MU_WZ
MU_WZ
#' GE_bias_normal_squaredmis.R#
#'#
#' A function to calculate the bias in testing for GxE interaction.#
#' Here we make the following assumptions:#
#' (1) All covariates (besides E) are marginally normally distributed with #
#' unit variance.  In addition, E,Z,W have mean 0.#
#' (2) G is generated by means of thresholding two independent normal RVs (jointly generated#
#' with the other covariates) and is centered to have mean 0.#
#' (3) The misspecification is of the form f(E)=h(E)=E^2, and M_j=W_j^2 for all j. In particular,#
#' W always has the same length as M here.#
#' #
#' In this version, some or all covariate terms may not exist, and some or all can be vectors.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' If Z or M is a vector, then beta_Z and beta_M should be vectors.#
#' @param rho_list A list of the 6 pairwise covariances between the#
#' covariates.  These should be in the order (1) cov_GE (2) cov_GZ (3) cov_EZ#
#' (4) cov_GW (5) cov_EW (6) cov_ZW.#
#' Again if Z or M are vectors then terms like cov_GZ should be vectors (in the appropriate order)#
#' If Z or M are vectors, then cov_ZW should be a vector in the order (cov(Z_1,W_1),...,cov(Z_1,W_q),#
#' cov(Z_2,W_1),........,cov(Z_p,W_q) where Z is a vector of length p and W is a vector of length q.#
#' @param cov_Z Only used if Z is a vector, gives the covariance matrix of Z (remember by assumption#
#' Z has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param cov_W Only used if W is a vector, gives the covariance matrix of W (remember by assumption#
#' W has mean 0 and variance 1).  The (i,j) element of the matrix should be the (i-1)(i-2)/2+j element#
#' of the vector.#
#' @param prob_G Probability that each allele is equal to 1.  Since each SNP has#
#' two alleles, the expectation of G is 2*prob_G.#
#' #
#' @keywords bias normal squared_misspecification#
#' @export#
#' @examples #
#' GE_bias_normal_squaredmis( beta_list=runif(n=6, min=0, max=1), rho_list=rep(0.3,1), prob_G=0.3)#
#
GE_bias_normal_squaredmis <- function(beta_list, rho_list, prob_G, cov_Z=NULL, cov_W=NULL)#
{#
  # Record some initial quantities#
  num_Z <- length(beta_list[[5]])#
  num_W <- length(beta_list[[6]])#
  rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  beta_0 <- beta_list[[1]]; beta_G <- beta_list[[2]]; beta_E <- beta_list[[3]]#
  beta_I <- beta_list[[4]]; BETA_Z <- beta_list[[5]]; BETA_M <- beta_list[[6]]#
#
  # Some error checking, make sure the covariance matrix is ok#
  translated_inputs <- GE_translate_inputs(beta_list, rho_list, prob_G, cov_Z, cov_W)#
  sig_mat <- translated_inputs$sig_mat_total#
  sig_mat_ZZ <- translated_inputs$sig_mat_ZZ#
  sig_mat_WW <- translated_inputs$sig_mat_WW#
  # Obvious and by assumptions#
  MU_Z <- rep(0, num_Z) 		# Some obvious ones#
  MU_M <- rep(1, num_W)		#
  MU_W <- rep(0, num_W)			#
  mu_f <- 1#
  mu_h <- 1#
  # Done translating inputs#
  # Now calculate other necessary terms that have #
  # been determined by our assumptions + inputs#
  #########################
  # Covariances#
  mu_GE <- rho_GE#
  mu_Gf <- 2*r_GE^2*w*dnorm(w) + 2*surv(w) - 2*prob_G#
  mu_Gh <- mu_Gf#
  mu_GG <- 2*prob_G*(1-prob_G)#
  MU_GZ <- rho_GZ  	# Vector#
  MU_GW <- rho_GW		# Vector#
  MU_GM <- 	2*r_GW^2*w*dnorm(w) + 2*surv(w) - 2*prob_G	# Vector, see gen_cor_bin_normal for explanation#
  MU_EM <- 	rep(0, num_W)				# Vector, in particular because third moment of W is 0#
  MU_EZ <- rho_EZ			# Vector#
  MU_EW <- rho_EW			# Vector#
  mu_EE <- 1#
  mu_Ef <- 0#
  MU_fZ <- 	rep(0, num_Z)	# Vector#
  MU_fW <- 	rep(0, num_W)		# Vector#
  #########################
  # Matrix covariances#
  # MU_ZW is not the same as MU_WZ because the dimensions of the matrix are not the same!#
  # Remember the covariances in rho_ZW are in the order cov(Z_1,W_1), cov(Z_1,W_2), ..., cov(Z_2,W_1),...#
  MU_ZW <- matrix(data=rho_ZW, nrow=num_Z, ncol=num_W, byrow=TRUE)	# Matrix	 #
  MU_WZ <- t(MU_ZW)#
  MU_ZM <- matrix(data=0, nrow=num_Z, ncol=num_W) 		# Matrix#
  MU_WM <- matrix(data=0, nrow=num_W, ncol=num_W) 			# Matrix#
  MU_ZZ <- sig_mat_ZZ 		# Matrix#
  MU_WW <- sig_mat_WW		# Matrix#
  #########################
  # Higher order moments#
  # We need as intermediate quantities E[G_1E], E[G_1E^2], E[G_1E^3], E[G_1G_2E], E[G_1G_2E^2], E[G1EZ], #
  # E[G1EW], E[G1EW^2], E[G1WE^2], E[G1ZE^2], E[G1G2E^2]#
  mu_G1_E <- r_GE*dnorm(w)#
  mu_G1_EE <- r_GE^2*w*dnorm(w) + surv(w)#
  mu_G1_EEE <- r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w)#
  # E[G1G2E] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_E <- function(x,w,r_GE) {#
  	x*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_E <- quadinf(f=f_G1_G2_E, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^2] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EE <- function(x,w,r_GE) {#
  	x^2*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EE <- quadinf(f=f_G1_G2_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # E[G1G2E^3] requires numerical integration#
  temp_sig <- matrix(data=c(1-r_GE^2, -r_GE^2, -r_GE^2, 1-r_GE^2), nrow=2)#
  f_G1_G2_EEE <- function(x,w,r_GE) {#
  	x^3*dnorm(x)*pmvnorm(lower=c(w,w), upper=c(Inf,Inf), mean=c(r_GE*x, r_GE*x), sigma=temp_sig)#
  }#
  mu_G1_G2_EEE <- quadinf(f=f_G1_G2_EEE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE)$Q[1]#
  # See gen_cor_bin_normal to see how to do these#
  mu_GGE <- 2*mu_G1_E + 2*mu_G1_G2_E - 8*prob_G*mu_G1_E#
  mu_GGh <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GEE <- mu_Gf#
  mu_GEf <- 2*(r_GE^3*w^2*dnorm(w) - r_GE^3*dnorm(w) + 3*r_GE*dnorm(w))#
  mu_GEh <- mu_GEf#
  mu_GGEE <- 2*mu_G1_EE + 2*mu_G1_G2_EE + 4*prob_G^2*1 - 8*prob_G*mu_G1_EE#
  mu_GGEf <- 2*mu_G1_EEE + 2*mu_G1_G2_EEE + 4*prob_G^2*0 - 8*prob_G*mu_G1_EEE#
  mu_GGEh <- mu_GGEf#
  ###############
  # Harder ones involving Z and W#
  # E[G1EZ] requires numerical integration#
  f_G1_E_Z <- function(x, w, r_EZ, r_GE, r_GZ) {#
  	( r_EZ * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GZ-r_GE*r_GZ) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_Z <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_E_Z[i] <- quadinf(f= f_G1_E_Z, xa=-Inf, xb=Inf, w=w, r_EZ=rho_EZ[i], r_GE=r_GE, r_GZ=r_GZ[i])$Q#
  }#
  # E[G1EW] requires numerical integration#
  f_G1_E_W <- function(x, w, r_EW, r_GE, r_GW) {#
  	( r_EW * x * surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / sqrt(1-r_GE^2) ) * #
  		(r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x* dnorm(x)#
  }#
  mu_G1_E_W <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_W[i] <- quadinf(f= f_G1_E_W, xa=-Inf, xb=Inf, w=w, r_EW=rho_EW[i], r_GE=r_GE, r_GW=r_GW[i])$Q#
  }#
  # E[G1EW^2] requires numerical integration#
  f_G1_E_WW <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GW) / sqrt(1-r_GW^2) ) + dnorm( (w-r_GW*x) / #
  		sqrt(1-r_GW^2) ) * (r_GE-r_GW*r_EW) / sqrt(1-r_GW^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_E_WW <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_E_WW[i] <- quadinf(f=f_G1_E_WW, xa=-Inf, xb=Inf, w=w , r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1WE^2] requires numerical integration#
  f_G1_W_EE <- function(x, w, r_GE, r_GW, r_EW) {#
  	( r_EW * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GW-r_GE*r_EW) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_W_EE <- rep(NA, num_W)#
  for (i in 1:num_W) {#
  	mu_G1_W_EE[i] <- quadinf(f=f_G1_W_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GW=r_GW[i], r_EW=rho_EW[i])$Q#
  }#
  # E[G1ZE^2] requires numerical integration#
  f_G1_Z_EE <- function(x, w, r_GE, r_GZ, r_EZ) {#
  	( r_EZ * x* surv( (w-x*r_GE) / sqrt(1-r_GE^2) ) + dnorm( (w-r_GE*x) / #
  		sqrt(1-r_GE^2) ) * (r_GZ-r_GE*r_EZ) / sqrt(1-r_GE^2) ) * x^2 * dnorm(x)#
  }#
  mu_G1_Z_EE <- rep(NA, num_Z)#
  for (i in 1:num_Z) {#
  	mu_G1_Z_EE[i] <- quadinf(f=f_G1_Z_EE, xa=-Inf, xb=Inf, w=w, r_GE=r_GE, r_GZ=r_GZ[i], r_EZ=rho_EZ[i])$Q#
  }#
#
  # See gen_cor_bin_normal to see how to do these (vectors)#
  MU_GEZ <- 2*mu_G1_E_Z - 2*prob_G*rho_EZ			# Vector#
  MU_GEW <- 2*mu_G1_E_W	- 2*prob_G*rho_EW			# Vector#
  MU_GEM <-	2*mu_G1_E_WW							# Vector#
  MU_GhW <- 2*mu_G1_W_EE#
  MU_GhZ <- 2*mu_G1_Z_EE#
  #########################
  # Some shortcut quantities#
  A <- (mu_GE * MU_GZ / mu_GG - MU_EZ) / (mu_EE - mu_GE^2/mu_GG)#
  B <- (mu_GE * MU_GW / mu_GG - MU_EW) / (mu_EE - mu_GE^2/mu_GG)#
  O <- MU_Z%*%t(MU_Z) + MU_GZ%*%t(MU_GZ)/mu_GG - MU_ZZ - A %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG)#
  C <- (B %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG) - MU_W%*%t(MU_Z) - MU_GW%*%t(MU_GZ)/mu_GG + MU_WZ) %*% solve(O)#
  Q <- MU_W%*%t(MU_W) + MU_GW%*%t(MU_GW)/mu_GG - MU_WW + B %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + #
    C %*% ( MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW + A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) )#
  D <- (mu_GE * mu_GGE / mu_GG - mu_GEE) / (mu_EE - mu_GE^2 / mu_GG)#
  E <- t(MU_GEZ - MU_Z*mu_GE - MU_GZ*mu_GGE/mu_GG + D*(MU_EZ - MU_GZ*mu_GE/mu_GG)) %*% solve(O)#
  EFF <- ( t(MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + D*(MU_GW * mu_GE / mu_GG - MU_EW)) + #
             E %*% (A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) ) %*% solve(Q)#
  # Solve for \alpha_I#
  alpha_I_num <- beta_E * (-mu_f*mu_GE - mu_Gf*mu_GGE/mu_GG + mu_GEf + D * (mu_Ef - mu_Gf*mu_GE/mu_GG)) +#
    beta_E * E %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-mu_Gf*mu_GE - mu_GGh*mu_GGE/mu_GG + mu_GGEh + D * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * E %*% (-mu_Gh*MU_Z - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    t(MU_GEM - MU_M*mu_GE - MU_GM*mu_GGE/mu_GG + D * (MU_EM - MU_GM*mu_GE/mu_GG)) %*% BETA_M + #
    E %*% (A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M - #
    beta_E * EFF %*% (-mu_f*MU_W - MU_GW*mu_Gf/mu_GG + MU_fW + B %*% as.matrix(mu_GEf - mu_GGh*mu_GE/mu_GG)) - #
    beta_E * EFF %*% C %*% (-mu_f*MU_Z - mu_Gf*MU_GZ/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) - #
    beta_I * EFF %*% (-mu_Gh*MU_W - MU_GW*mu_GGh/mu_GG + MU_GhW + B %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) -#
    beta_I * EFF %*% C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A %*% as.matrix(mu_GEh - mu_GGh*mu_GE/mu_GG)) - #
    EFF %*% ( -MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM + B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) ) %*% BETA_M - #
    EFF %*% C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M#
  alpha_I_denom <- EFF %*% ( MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) +#
    EFF %*% C %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    ( mu_GE^2 + mu_GGE^2/mu_GG - mu_GGEE + D * (mu_GGE*mu_GE/mu_GG - mu_GEE) ) - #
    E %*% ( MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG + A * (mu_GGE*mu_GE/mu_GG - mu_GEE) )#
  alpha_I <- alpha_I_num / alpha_I_denom#
  R <- beta_E * (-MU_W*mu_f - MU_GW*mu_Gf/mu_GG + MU_fW + B * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_E * C %*% (-mu_f*MU_Z - MU_GZ*mu_Gf/mu_GG + MU_fZ + A %*% as.matrix(mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (-MU_W*mu_Gh - MU_GW*mu_GGh/mu_GG + MU_GhW + B * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    beta_I * C %*% (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    ( B %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_W%*%t(MU_M) - MU_GW%*%t(MU_GM)/mu_GG + MU_WM) %*% BETA_M + #
    C %*% ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    alpha_I * (MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + B * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    as.numeric(alpha_I) * C %*% (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A*(mu_GGE*mu_GE/mu_GG - mu_GEE))#
  ALPHA_W <- - solve(Q) %*% R#
  P <- beta_E * (-MU_Z*mu_f - MU_GZ*mu_Gf/mu_GG + MU_fZ + A * (mu_Ef - mu_Gf*mu_GE/mu_GG)) + #
    beta_I * (MU_GhZ - MU_Z*mu_Gh - MU_GZ*mu_GGh/mu_GG + A * (mu_GEh - mu_GGh*mu_GE/mu_GG)) + #
    alpha_I * (MU_Z*mu_GE + MU_GZ*mu_GGE/mu_GG - MU_GEZ + A * (mu_GGE*mu_GE/mu_GG - mu_GEE)) + #
    ( A %*% t(MU_EM - MU_GM*mu_GE/mu_GG) - MU_Z%*%t(MU_M) - MU_GZ%*%t(MU_GM)/mu_GG + MU_ZM) %*% BETA_M + #
    ( A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) %*% ALPHA_W#
  Bz_Az <- solve(O) %*% P#
  ALPHA_Z <- BETA_Z - solve(O) %*% P#
  alpha_E <- ( beta_E * (mu_Ef - mu_Gf*mu_GE/mu_GG) + beta_I * (mu_GEh - mu_GGh*mu_GE/mu_GG) +  #
                 alpha_I * (mu_GGE*mu_GE/mu_GG - mu_GEE) + t(MU_EZ - MU_GZ*mu_GE/mu_GG) %*% Bz_Az + #
                 t(MU_EM - MU_GM*mu_GE/mu_GG) %*% BETA_M + t(MU_GW*mu_GE/mu_GG - MU_EW) %*% ALPHA_W ) /#
    (mu_EE - mu_GE^2/mu_GG)#
  Bg_Ag <- ( alpha_E*mu_GE - beta_E*mu_Gf + alpha_I*mu_GGE - beta_I*mu_GGh - t(MU_GZ) %*% Bz_Az + #
               t(MU_GW) %*% ALPHA_W - t(MU_GM) %*% BETA_M ) / mu_GG#
  alpha_G <- beta_G - Bg_Ag#
  alpha_0 <- beta_0 + beta_E*mu_f + beta_I*mu_Gh - alpha_I*mu_GE + t(MU_Z) %*% Bz_Az +#
    t(MU_M) %*% BETA_M - t(MU_W) %*% ALPHA_W#
  # Return #
  return(list(alpha_list=list(alpha_0, alpha_G, alpha_E, alpha_I, ALPHA_Z, ALPHA_W),#
              beta_list = list(beta_0, beta_G, beta_E, beta_I, BETA_Z, BETA_M),#
              mu_list = list(mu_f, mu_h, MU_M),#
              cov_list = list(mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
              mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW),#
              MU_ZZ=MU_ZZ, MU_ZM=MU_ZM, MU_ZW=MU_ZW, MU_WZ=MU_WZ, MU_WM=MU_WM, MU_WW=MU_WW,#
              HOM_list = list(mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
              MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)))#
}
#' GE_nleqslv#
#'#
#' Deprecated version as of Sep 27, 2016.  Designed only to work with scalar Z and W/M.#
#'#
#' Here we use the package nleqslv to get a numerical solution which#
#' we can use to check our direct solution.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' @param mu_list A list of the means for f, h, M, Z, W in that order.#
#' @param cov_list A list of the covariances in the order#
#' (mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
#' mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW)#
#' @param MU_ZZ Matrix mean#
#' @param MU_ZM Matrix mean#
#' @param MU_ZW Matrix mean#
#' @param MU_WZ Matrix mean#
#' @param MU_WM Matrix mean#
#' @param MU_WW Matrix mean#
#' @param HOM_list A vector of the higher order moments in the order#
#' (mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
#' MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)#
#'#
#' @keywords nonlinear equation#
#' @export#
#' @examples #
#' GE_bias_results <- GE_bias_normal_squaredmis(runif(6), runif(3), runif(10))#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_list, GE_bias_results$cov_list,#
#' GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW, GE_bias_results$MU_WZ,#
#' GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_list)#
#
GE_nleqslv <- function(beta_list, mu_list, cov_list, MU_ZZ, MU_ZM, MU_ZW, MU_WM, MU_WW, HOM_list)#
{#
#
	# Here we extract the relevant parameters from the inputs#
	beta_0 <- beta_list[[1]]#
	beta_G <- beta_list[[2]]#
	beta_E <- beta_list[[3]]#
	beta_I <- beta_list[[4]]#
	BETA_Z <- beta_list[[5]]#
	BETA_M <- beta_list[[6]]#
#
	mu_f <- mu_list[[1]]#
	mu_h <- mu_list[[2]]#
	MU_M <- mu_list[[3]]#
	MU_Z <- mu_list[[4]]#
	MU_W <- mu_list[[5]]#
	num_Z <- length(BETA_Z)#
	num_W <- length(MU_W)#
	mu_GG <- cov_list[[1]]#
	mu_GE <- cov_list[[2]]#
	mu_Gf <- cov_list[[3]]#
	mu_Gh <- cov_list[[4]]#
	MU_GZ <- cov_list[[5]]#
	MU_GM <- cov_list[[6]]#
	MU_GW <- cov_list[[7]]#
	mu_EE <- cov_list[[8]]#
	mu_Ef <- cov_list[[9]]#
	MU_EZ <- cov_list[[10]]#
	MU_EM <- cov_list[[11]]#
	MU_EW <- cov_list[[12]]#
	MU_fZ <- cov_list[[13]]#
	MU_fW <- cov_list[[14]]#
	mu_GGE <- HOM_list[[1]]#
	mu_GGh <- HOM_list[[2]]#
	mu_GEE <- HOM_list[[3]]#
	mu_GEf <- HOM_list[[4]]#
	mu_GEh <- HOM_list[[5]]#
	MU_GEZ <- HOM_list[[6]]#
	MU_GEM <- HOM_list[[7]]#
	MU_GEW <- HOM_list[[8]]#
	MU_GhW <- HOM_list[[9]]#
	MU_GhZ <- HOM_list[[10]]#
	mu_GGEE <- HOM_list[[11]]#
	mu_GGEf <- HOM_list[[12]]#
	mu_GGEh <- HOM_list[[13]]#
	#################################################################			#
	# Define the set of score equations we will be solving#
	score_eqs <- function(x)#
	{#
		alpha_0 <- x[1]#
		alpha_G <- x[2]#
		alpha_E <- x[3]#
		alpha_I <- x[4]#
		ALPHA_Z <- x[5:(4+num_Z)]#
		ALPHA_W <- x[(5+num_Z):(4+num_Z+num_W)]#
		y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M#
		y[2] = alpha_G*mu_GG + alpha_E*mu_GE + alpha_I*mu_GGE + t(MU_GZ) %*% ALPHA_Z + t(MU_GW) %*% ALPHA_W - #
			beta_G*mu_GG - beta_E*mu_Gf - beta_I*mu_GGh - t(MU_GZ) %*% BETA_Z - t(MU_GM) %*% BETA_M#
		y[3] = alpha_G*mu_GE + alpha_E*mu_EE + alpha_I*mu_GEE + t(MU_EZ) %*% ALPHA_Z + t(MU_EW) %*% ALPHA_W - #
			beta_G*mu_GE - beta_E*mu_Ef - beta_I*mu_GEh - t(MU_EZ) %*% BETA_Z - t(MU_EM) %*% BETA_M#
		y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M#
		y[5:(4+num_Z)] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M#
		y[(5+num_Z):(4+num_Z+num_W)] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_WZ %*% BETA_Z - MU_WM %*% BETA_M#
		y#
	}#
	solved_scoreeqs = nleqslv::nleqslv(x=c(0,0,0,0, rep(0, (num_Z+num_W))), fn=score_eqs)#
	return(solved_scoreeqs)#
}
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)#
#
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )#
#
cov_list <- solve_results$cov_list#
HOM_list <- solve_results$HOM_list
GE_nleqslv(beta_list, mu_list, cov_list, MU_ZZ=solve_results$MU_ZZ, MU_ZM=solve_results$MU_ZM,#
		MU_ZW=solve_results$MU_ZW, MU_WZ=solve_results$MU_WZ, MU_WM=solve_results$MU_WM, MU_WW=solve_results$MU_WW, HOM_list)
#' GE_nleqslv#
#'#
#' Deprecated version as of Sep 27, 2016.  Designed only to work with scalar Z and W/M.#
#'#
#' Here we use the package nleqslv to get a numerical solution which#
#' we can use to check our direct solution.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' @param mu_list A list of the means for f, h, M, Z, W in that order.#
#' @param cov_list A list of the covariances in the order#
#' (mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
#' mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW)#
#' @param MU_ZZ Matrix mean#
#' @param MU_ZM Matrix mean#
#' @param MU_ZW Matrix mean#
#' @param MU_WZ Matrix mean#
#' @param MU_WM Matrix mean#
#' @param MU_WW Matrix mean#
#' @param HOM_list A vector of the higher order moments in the order#
#' (mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
#' MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)#
#'#
#' @keywords nonlinear equation#
#' @export#
#' @examples #
#' GE_bias_results <- GE_bias_normal_squaredmis(runif(6), runif(3), runif(10))#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_list, GE_bias_results$cov_list,#
#' GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW, GE_bias_results$MU_WZ,#
#' GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_list)#
#
GE_nleqslv <- function(beta_list, mu_list, cov_list, MU_ZZ, MU_ZM, MU_ZW, MU_WZ, MU_WM, MU_WW, HOM_list)#
{#
#
	# Here we extract the relevant parameters from the inputs#
	beta_0 <- beta_list[[1]]#
	beta_G <- beta_list[[2]]#
	beta_E <- beta_list[[3]]#
	beta_I <- beta_list[[4]]#
	BETA_Z <- beta_list[[5]]#
	BETA_M <- beta_list[[6]]#
#
	mu_f <- mu_list[[1]]#
	mu_h <- mu_list[[2]]#
	MU_M <- mu_list[[3]]#
	MU_Z <- mu_list[[4]]#
	MU_W <- mu_list[[5]]#
	num_Z <- length(BETA_Z)#
	num_W <- length(MU_W)#
	mu_GG <- cov_list[[1]]#
	mu_GE <- cov_list[[2]]#
	mu_Gf <- cov_list[[3]]#
	mu_Gh <- cov_list[[4]]#
	MU_GZ <- cov_list[[5]]#
	MU_GM <- cov_list[[6]]#
	MU_GW <- cov_list[[7]]#
	mu_EE <- cov_list[[8]]#
	mu_Ef <- cov_list[[9]]#
	MU_EZ <- cov_list[[10]]#
	MU_EM <- cov_list[[11]]#
	MU_EW <- cov_list[[12]]#
	MU_fZ <- cov_list[[13]]#
	MU_fW <- cov_list[[14]]#
	mu_GGE <- HOM_list[[1]]#
	mu_GGh <- HOM_list[[2]]#
	mu_GEE <- HOM_list[[3]]#
	mu_GEf <- HOM_list[[4]]#
	mu_GEh <- HOM_list[[5]]#
	MU_GEZ <- HOM_list[[6]]#
	MU_GEM <- HOM_list[[7]]#
	MU_GEW <- HOM_list[[8]]#
	MU_GhW <- HOM_list[[9]]#
	MU_GhZ <- HOM_list[[10]]#
	mu_GGEE <- HOM_list[[11]]#
	mu_GGEf <- HOM_list[[12]]#
	mu_GGEh <- HOM_list[[13]]#
	#################################################################			#
	# Define the set of score equations we will be solving#
	score_eqs <- function(x)#
	{#
		alpha_0 <- x[1]#
		alpha_G <- x[2]#
		alpha_E <- x[3]#
		alpha_I <- x[4]#
		ALPHA_Z <- x[5:(4+num_Z)]#
		ALPHA_W <- x[(5+num_Z):(4+num_Z+num_W)]#
		y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M#
		y[2] = alpha_G*mu_GG + alpha_E*mu_GE + alpha_I*mu_GGE + t(MU_GZ) %*% ALPHA_Z + t(MU_GW) %*% ALPHA_W - #
			beta_G*mu_GG - beta_E*mu_Gf - beta_I*mu_GGh - t(MU_GZ) %*% BETA_Z - t(MU_GM) %*% BETA_M#
		y[3] = alpha_G*mu_GE + alpha_E*mu_EE + alpha_I*mu_GEE + t(MU_EZ) %*% ALPHA_Z + t(MU_EW) %*% ALPHA_W - #
			beta_G*mu_GE - beta_E*mu_Ef - beta_I*mu_GEh - t(MU_EZ) %*% BETA_Z - t(MU_EM) %*% BETA_M#
		y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M#
		y[5:(4+num_Z)] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M#
		y[(5+num_Z):(4+num_Z+num_W)] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_WZ %*% BETA_Z - MU_WM %*% BETA_M#
		y#
	}#
	solved_scoreeqs = nleqslv::nleqslv(x=c(0,0,0,0, rep(0, (num_Z+num_W))), fn=score_eqs)#
	return(solved_scoreeqs)#
}
GE_nleqslv(beta_list, mu_list, cov_list, MU_ZZ=solve_results$MU_ZZ, MU_ZM=solve_results$MU_ZM,#
		MU_ZW=solve_results$MU_ZW, MU_WZ=solve_results$MU_WZ, MU_WM=solve_results$MU_WM, MU_WW=solve_results$MU_WW, HOM_list)
# Here we extract the relevant parameters from the inputs#
	beta_0 <- beta_list[[1]]#
	beta_G <- beta_list[[2]]#
	beta_E <- beta_list[[3]]#
	beta_I <- beta_list[[4]]#
	BETA_Z <- beta_list[[5]]#
	BETA_M <- beta_list[[6]]#
#
	mu_f <- mu_list[[1]]#
	mu_h <- mu_list[[2]]#
	MU_M <- mu_list[[3]]#
	MU_Z <- mu_list[[4]]#
	MU_W <- mu_list[[5]]#
	num_Z <- length(BETA_Z)#
	num_W <- length(MU_W)#
	mu_GG <- cov_list[[1]]#
	mu_GE <- cov_list[[2]]#
	mu_Gf <- cov_list[[3]]#
	mu_Gh <- cov_list[[4]]#
	MU_GZ <- cov_list[[5]]#
	MU_GM <- cov_list[[6]]#
	MU_GW <- cov_list[[7]]#
	mu_EE <- cov_list[[8]]#
	mu_Ef <- cov_list[[9]]#
	MU_EZ <- cov_list[[10]]#
	MU_EM <- cov_list[[11]]#
	MU_EW <- cov_list[[12]]#
	MU_fZ <- cov_list[[13]]#
	MU_fW <- cov_list[[14]]#
	mu_GGE <- HOM_list[[1]]#
	mu_GGh <- HOM_list[[2]]#
	mu_GEE <- HOM_list[[3]]#
	mu_GEf <- HOM_list[[4]]#
	mu_GEh <- HOM_list[[5]]#
	MU_GEZ <- HOM_list[[6]]#
	MU_GEM <- HOM_list[[7]]#
	MU_GEW <- HOM_list[[8]]#
	MU_GhW <- HOM_list[[9]]#
	MU_GhZ <- HOM_list[[10]]#
	mu_GGEE <- HOM_list[[11]]#
	mu_GGEf <- HOM_list[[12]]#
	mu_GGEh <- HOM_list[[13]]
x
alpha_0 <- x[1]#
		alpha_G <- x[2]#
		alpha_E <- x[3]#
		alpha_I <- x[4]#
		ALPHA_Z <- x[5:(4+num_Z)]#
		ALPHA_W <- x[(5+num_Z):(4+num_Z+num_W)]#
		y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M#
		y[2] = alpha_G*mu_GG + alpha_E*mu_GE + alpha_I*mu_GGE + t(MU_GZ) %*% ALPHA_Z + t(MU_GW) %*% ALPHA_W - #
			beta_G*mu_GG - beta_E*mu_Gf - beta_I*mu_GGh - t(MU_GZ) %*% BETA_Z - t(MU_GM) %*% BETA_M#
		y[3] = alpha_G*mu_GE + alpha_E*mu_EE + alpha_I*mu_GEE + t(MU_EZ) %*% ALPHA_Z + t(MU_EW) %*% ALPHA_W - #
			beta_G*mu_GE - beta_E*mu_Ef - beta_I*mu_GEh - t(MU_EZ) %*% BETA_Z - t(MU_EM) %*% BETA_M#
		y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M#
		y[5:(4+num_Z)] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M
alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW
alpha_0*MU_W + alpha_G*MU_GW
alpha_E*MU_EW + alpha_I*MU_GEW + MU_ZW %*% ALPHA_Z
alpha_G*MU_GW
MU_GW
alpha_E*MU_EW
MU_GEW
MU_ZW
y[(5+num_Z):(4+num_Z+num_W)] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_WZ %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_WZ %*% BETA_Z - MU_WM %*% BETA_M
MU_WZ
MU_WZ=solve_results$MU_WZ
MU_WZ
y[(5+num_Z):(4+num_Z+num_W)] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_WZ %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_WZ %*% BETA_Z - MU_WM %*% BETA_M
#' GE_nleqslv#
#'#
#' Deprecated version as of Sep 27, 2016.  Designed only to work with scalar Z and W/M.#
#'#
#' Here we use the package nleqslv to get a numerical solution which#
#' we can use to check our direct solution.#
#' #
#' @param beta_list A list of the effect sizes in the true model.#
#' Use the order beta_0, beta_G, beta_E, beta_I, beta_Z, beta_M.#
#' @param mu_list A list of the means for f, h, M, Z, W in that order.#
#' @param cov_list A list of the covariances in the order#
#' (mu_GG, mu_GE, mu_Gf, mu_Gh, MU_GZ, MU_GM, MU_GW, mu_EE,#
#' mu_Ef, MU_EZ, MU_EM, MU_EW, MU_fZ, MU_fW)#
#' @param MU_ZZ Matrix mean#
#' @param MU_ZM Matrix mean#
#' @param MU_ZW Matrix mean#
#' @param MU_WZ Matrix mean#
#' @param MU_WM Matrix mean#
#' @param MU_WW Matrix mean#
#' @param HOM_list A vector of the higher order moments in the order#
#' (mu_GGE, mu_GGh, mu_GEE, mu_GEf, mu_GEh, MU_GEZ, MU_GEM, MU_GEW,#
#' MU_GhW, MU_GhZ, mu_GGEE, mu_GGEf, mu_GGEh)#
#'#
#' @keywords nonlinear equation#
#' @export#
#' @examples #
#' GE_bias_results <- GE_bias_normal_squaredmis(runif(6), runif(3), runif(10))#
#' GE_nleqslv(GE_bias_results$beta_list, GE_bias_results$mu_list, GE_bias_results$cov_list,#
#' GE_bias_results$MU_ZZ, GE_bias_results$MU_ZM, GE_bias_results$MU_ZW, GE_bias_results$MU_WZ,#
#' GE_bias_results$MU_WM, GE_bias_results$MU_WW, GE_bias_results$HOM_list)#
#
GE_nleqslv <- function(beta_list, mu_list, cov_list, MU_ZZ, MU_ZM, MU_ZW, MU_WZ, MU_WM, MU_WW, HOM_list)#
{#
#
	# Here we extract the relevant parameters from the inputs#
	beta_0 <- beta_list[[1]]#
	beta_G <- beta_list[[2]]#
	beta_E <- beta_list[[3]]#
	beta_I <- beta_list[[4]]#
	BETA_Z <- beta_list[[5]]#
	BETA_M <- beta_list[[6]]#
#
	mu_f <- mu_list[[1]]#
	mu_h <- mu_list[[2]]#
	MU_M <- mu_list[[3]]#
	MU_Z <- mu_list[[4]]#
	MU_W <- mu_list[[5]]#
	num_Z <- length(BETA_Z)#
	num_W <- length(MU_W)#
	mu_GG <- cov_list[[1]]#
	mu_GE <- cov_list[[2]]#
	mu_Gf <- cov_list[[3]]#
	mu_Gh <- cov_list[[4]]#
	MU_GZ <- cov_list[[5]]#
	MU_GM <- cov_list[[6]]#
	MU_GW <- cov_list[[7]]#
	mu_EE <- cov_list[[8]]#
	mu_Ef <- cov_list[[9]]#
	MU_EZ <- cov_list[[10]]#
	MU_EM <- cov_list[[11]]#
	MU_EW <- cov_list[[12]]#
	MU_fZ <- cov_list[[13]]#
	MU_fW <- cov_list[[14]]#
	mu_GGE <- HOM_list[[1]]#
	mu_GGh <- HOM_list[[2]]#
	mu_GEE <- HOM_list[[3]]#
	mu_GEf <- HOM_list[[4]]#
	mu_GEh <- HOM_list[[5]]#
	MU_GEZ <- HOM_list[[6]]#
	MU_GEM <- HOM_list[[7]]#
	MU_GEW <- HOM_list[[8]]#
	MU_GhW <- HOM_list[[9]]#
	MU_GhZ <- HOM_list[[10]]#
	mu_GGEE <- HOM_list[[11]]#
	mu_GGEf <- HOM_list[[12]]#
	mu_GGEh <- HOM_list[[13]]#
	#################################################################			#
	# Define the set of score equations we will be solving#
	score_eqs <- function(x)#
	{#
		alpha_0 <- x[1]#
		alpha_G <- x[2]#
		alpha_E <- x[3]#
		alpha_I <- x[4]#
		ALPHA_Z <- x[5:(4+num_Z)]#
		ALPHA_W <- x[(5+num_Z):(4+num_Z+num_W)]#
		y <- numeric(4+num_Z+num_W)#
		y[1] = alpha_0 + alpha_I*mu_GE + t(MU_Z) %*% ALPHA_Z + t(MU_W) %*% ALPHA_W - beta_0 - #
			beta_E*mu_f - beta_I*mu_Gh - t(MU_Z) %*% BETA_Z - t(MU_M) %*% BETA_M#
		y[2] = alpha_G*mu_GG + alpha_E*mu_GE + alpha_I*mu_GGE + t(MU_GZ) %*% ALPHA_Z + t(MU_GW) %*% ALPHA_W - #
			beta_G*mu_GG - beta_E*mu_Gf - beta_I*mu_GGh - t(MU_GZ) %*% BETA_Z - t(MU_GM) %*% BETA_M#
		y[3] = alpha_G*mu_GE + alpha_E*mu_EE + alpha_I*mu_GEE + t(MU_EZ) %*% ALPHA_Z + t(MU_EW) %*% ALPHA_W - #
			beta_G*mu_GE - beta_E*mu_Ef - beta_I*mu_GEh - t(MU_EZ) %*% BETA_Z - t(MU_EM) %*% BETA_M#
		y[4] = alpha_0*mu_GE + alpha_G*mu_GGE + alpha_E*mu_GEE + alpha_I*mu_GGEE + t(MU_GEZ) %*% ALPHA_Z + #
			t(MU_GEW) %*% ALPHA_W - beta_0*mu_GE - beta_G*mu_GGE - beta_E*mu_GEf - beta_I*mu_GGEh -#
			t(MU_GEZ) %*% BETA_Z - t(MU_GEM) %*% BETA_M#
		y[5:(4+num_Z)] = alpha_0*MU_Z + alpha_G*MU_GZ + alpha_E*MU_EZ + alpha_I*MU_GEZ + MU_ZZ %*% ALPHA_Z + #
			MU_ZW %*% ALPHA_W - beta_0*MU_Z - beta_G*MU_GZ - beta_E*MU_fZ - beta_I*MU_GhZ - #
			MU_ZZ %*% BETA_Z - MU_ZM %*% BETA_M#
		y[(5+num_Z):(4+num_Z+num_W)] = alpha_0*MU_W + alpha_G*MU_GW + alpha_E*MU_EW + alpha_I*MU_GEW + MU_WZ %*% ALPHA_Z + #
			MU_WW %*% ALPHA_W - beta_0*MU_W - beta_G*MU_GW - beta_E*MU_fW - beta_I*MU_GhW -#
			MU_WZ %*% BETA_Z - MU_WM %*% BETA_M#
		y#
	}#
	solved_scoreeqs = nleqslv::nleqslv(x=c(0,0,0,0, rep(0, (num_Z+num_W))), fn=score_eqs)#
	return(solved_scoreeqs)#
}
GE_nleqslv(beta_list, mu_list, cov_list, MU_ZZ=solve_results$MU_ZZ, MU_ZM=solve_results$MU_ZM,#
		MU_ZW=solve_results$MU_ZW, MU_WZ=solve_results$MU_WZ, MU_WM=solve_results$MU_WM, MU_WW=solve_results$MU_WW, HOM_list)
solve_results$alpha_list
ell = list(MU_ZW, MU_WZ)
ell
rm(list=ls())
# Run some tests on GEint#
source('GE_bias_normal_squaredmis.R')#
source('GE_bias.R')#
source('GE_enumerate_inputs.R')#
source('GE_nleqslv.R')#
source('GE_scoreeq_sim.R')#
source('GE_test_moment_calcs.R')#
source('GE_translate_inputs.R')
setwd('/users/ryansun/documents/research/paper2/software/geint/R')
source('GE_bias_normal_squaredmis.R')#
source('GE_bias.R')#
source('GE_enumerate_inputs.R')#
source('GE_nleqslv.R')#
source('GE_scoreeq_sim.R')#
source('GE_test_moment_calcs.R')#
source('GE_translate_inputs.R')
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)
num_Z
num_W
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)
num_Z
num_W
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)
num_Z
num_W
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)
num_Z
num_W
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_Z <- NULL#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_W <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_W <- NULL#
}
# Test first#
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)#
sim_results <- GE_scoreeq_sim(beta_list=beta_list, prob_G=prob_G, rho_list=rho_list, cov_Z=cov_Z, cov_W=cov_W)#
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)#
#
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )
rm(list=ls())
source('GE_bias_normal_squaredmis.R')#
source('GE_bias.R')#
source('GE_enumerate_inputs.R')#
source('GE_nleqslv.R')#
source('GE_scoreeq_sim.R')#
source('GE_test_moment_calcs.R')#
source('GE_translate_inputs.R')
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_Z <- NULL#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_W <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_W <- NULL#
}
num_Z
num_W
# Test first#
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)#
sim_results <- GE_scoreeq_sim(beta_list=beta_list, prob_G=prob_G, rho_list=rho_list, cov_Z=cov_Z, cov_W=cov_W)#
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
rm(list=ls())
source('GE_bias_normal_squaredmis.R')#
source('GE_bias.R')#
source('GE_enumerate_inputs.R')#
source('GE_nleqslv.R')#
source('GE_scoreeq_sim.R')#
source('GE_test_moment_calcs.R')#
source('GE_translate_inputs.R')
num_Z=2
num_W=4
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_Z <- NULL#
}
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_W <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_W <- NULL#
}#
#
# Test first#
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)#
sim_results <- GE_scoreeq_sim(beta_list=beta_list, prob_G=prob_G, rho_list=rho_list, cov_Z=cov_Z, cov_W=cov_W)#
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_Z <- NULL#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_W <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_W <- NULL#
}#
#
# Test first#
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
sim_results <- GE_scoreeq_sim(beta_list=beta_list, prob_G=prob_G, rho_list=rho_list, cov_Z=cov_Z, cov_W=cov_W)
solve_results$alpha_list
sim_results$alpha_list
sim_results
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
source('GE_bias_normal_squaredmis.R')
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
source('GE_bias_normal_squaredmis.R')
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
source('GE_bias_normal_squaredmis.R')
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
sim_results#
solve_results$alpha_list
beta_list
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )
cov_list <- solve_results$cov_list#
HOM_list <- solve_results$HOM_list#
mat_cov_list <- list( MU_ZZ=solve_results$MU_ZZ, MU_WW=solve_results$MU_WW, MU_ZW=solve_results$MU_ZW,#
					MU_WZ=solve_results$MU_WZ, MU_ZM=solve_results$MU_ZM, MU_WM=solve_results$MU_WM)#
#
nleqslv_results <- GE_nleqslv(beta_list, cov_list, mat_cov_list, mu_list, HOM_list)
source('GE_nleqslv.R')
nleqslv_results <- GE_nleqslv(beta_list, cov_list, cov_mat_list, mu_list, HOM_list)
cov_mat_list <- list( MU_ZZ=solve_results$MU_ZZ, MU_WW=solve_results$MU_WW, MU_ZW=solve_results$MU_ZW,
MU_WZ=solve_results$MU_WZ, MU_ZM=solve_results$MU_ZM, MU_WM=solve_results$MU_WM)
nleqslv_results <- GE_nleqslv(beta_list, cov_list, cov_mat_list, mu_list, HOM_list)
nleqslv_results
sim_results
source('GE_bias.R')
ge_bias_results <- GE_bias(beta_list, cov_list, cov_mat_list, mu_list, HOM_list)
ge_bias_results
return(list(alpha_0, alpha_G, alpha_E, alpha_I, ALPHA_Z, ALPHA_W))
source('GE_bias.R')
ge_bias_results <- GE_bias(beta_list, cov_list, cov_mat_list, mu_list, HOM_list)
ge_bias_results
sim_results
