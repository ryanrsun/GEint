Z = rnorm(n=100000, mean=A*G, sd=sdXgivenG) - ell
Z
mean(Z)
var(Z)
f3 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X*(dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) - #
	dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) )#
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
# the third integrand#
f3 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * X*(expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f4 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(beta_0 + beta_X*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(beta_0 + beta_X*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
f4 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(beta_0 + beta_X*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(beta_0 + beta_X*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
f4 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(b0 + b2*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(beta_0 + beta_X*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
f4 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(b0 + b2*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(b0 + b2*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
# the fourth integrand#
f4 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
var_X
sdXgivenG = sqrt(var_X - A^2*2*p*(1-p))
f4 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(b0 + b2*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(b0 + b2*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f1 <- function(X,emm,m,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * (expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * (expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * (expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the second integrand#
f2 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * (expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the third integrand#
f3 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * X*(expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the fourth integrand#
f4 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f1 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) - #
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}#
f2 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	dnorm(X, mean= cond.means.X[2], sd=sdXgivenG) * 2* probG*(1-probG) * expit(b0 + b2*X^2) - #
	dnorm(X, mean= cond.means.X[2], sd= sdXgivenG) * 2* probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2*dnorm(X, mean= cond.means.X[3], sd= sdXgivenG) * probG ^2 * expit(b0 + b2*X^2) - #
	2*dnorm(X, mean= cond.means.X[3], sd= sdXgivenG) * probG ^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}#
f3 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X*(dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) - #
	dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) )#
}#
f4 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(b0 + b2*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(b0 + b2*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
# Assume that X is marginally N(0, 1) and conditional on G, X has variance sd_X#
# As f1 is the function to be integrated, the dimension of 'x' is the dimension #
# of integration and the variables represented by 'x' are what is being integrated.#
f1 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=alpha_vec[1]; alpha_G=alpha_vec[2]; alpha_X=alpha_vec[3]; alpha_I=alpha_vec[4];#
	dnorm(x, mean=0, sd=1) * expit(beta_0 + beta_X*x^2) - #
	dnorm(x, mean=cond_mean[1], sd=sd_X) * (1-p)^2 * expit(alpha_0 + alpha_X*x) - #
	dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(alpha_0 + alpha_G + alpha_X*x + alpha_I*x) - #
	dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(alpha_0 + 2*alpha_G + alpha_X*x + 2*alpha_I*x) #
}#
#
f2 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=alpha_vec[1]; alpha_G=alpha_vec[2]; alpha_X=alpha_vec[3]; alpha_I=alpha_vec[4];#
	dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(beta_0 + beta_X*x^2) - #
	dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(alpha_0 + alpha_G + alpha_X*x + alpha_I*x) + #
	2*dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(beta_0 + beta_X*x^2) - #
	2*dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(alpha_0 + 2*alpha_G + alpha_X*x + 2*alpha_I*x) #
}#
#
f3 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=alpha_vec[1]; alpha_G=alpha_vec[2]; alpha_X=alpha_vec[3]; alpha_I=alpha_vec[4];#
	x * dnorm(x, mean=0, sd=1) * expit(beta_0 + beta_X*x^2) - #
	x * dnorm(x, mean=cond_mean[1], sd=sd_X) * (1-p)^2 * expit(alpha_0 + alpha_X*x) - #
	x * dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(alpha_0 + alpha_G + alpha_X*x + alpha_I*x) - #
	x * dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(alpha_0 + 2*alpha_G + alpha_X*x + 2*alpha_I*x) #
}#
#
f4 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=alpha_vec[1]; alpha_G=alpha_vec[2]; alpha_X=alpha_vec[3]; alpha_I=alpha_vec[4];#
	x * dnorm(x, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(beta_0 + beta_X*x^2) - #
	x * dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(alpha_0 + alpha_G + alpha_X*x + alpha_I*x) + #
	2 * x * dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(beta_0 + beta_X*x^2) - #
	2 * x * dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(alpha_0 + 2*alpha_G + alpha_X*x + 2*alpha_I*x) #
}#
#
score_eqs_one <- function(x, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_vec <- x#
	y <- numeric(4)#
	y[1] <- adaptIntegrate(f=f1, lowerLimit=-Inf, upperLimit=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)#
	y[2] <- adaptIntegrate(f=f2, lowerLimit=-Inf, upperLimit=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)#
	y[3] <- adaptIntegrate(f=f3, lowerLimit=-Inf, upperLimit=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)#
	y[4] <- adaptIntegrate(f=f4, lowerLimit=-Inf, upperLimit=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)#
	y#
}
score_eqs_one <- function(x, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_vec <- x#
	y <- numeric(4)#
	y[1] <- integrate(f=f1, lower=-Inf, upper=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)$value#
	y[2] <- integrate(f=f2, lower=-Inf, upper=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)$value#
	y[3] <- integrate(f=f3, lower=-Inf, upper=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)$value#
	y[4] <- integrate(f=f4, lower=-Inf, upper=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)$value#
	y#
}
A <- rho * sqrt(var_X) / sqrt(2*p*(1-p))#
cond_mean = (0:2)*A - (2*p*(1-p)*A + p^2*A)#
nleqslv(x=c(0,0,0,0), fn=score_eqs_one, p=0.3, cond_mean=cond_mean, sd_X=0.9539392, beta_0=0.3, beta_X=0.3)
0.5385000 -0.0166990 -0.1394579  0.2268865cond_mean
b0
nleqslv(x=c(0,0,0,0), fn=score_eqs_one, p=0.3, cond_mean=cond_mean, sd_X=0.9539392, beta_0=-1, beta_X=0.3)
score_eqs_one
score_eqs_one(x = rep(0.2,4), p =0.3)
score_eqs_one(x = rep(0.2,4), p =0.3, cond_mean=cond_mean, sd_X=sdXgivenG, beta_0=0.3, beta_X=0.3)
score.eqs(x=rep(0.2,4), cond.means.X=cond_mean, sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3)
score.eqs <- function(x, cond.means.X, sdXgivenG, emm, b0, b1, b2, b3, probG){#
	y <- numeric(4)#
#
	y[1] <- integrate(f1,z=x,emm=emm,cond.means.X=cond.means.X,sdXgivenG=sdXgivenG,b0=b0,b1=b1,b2=b2,b3=b3,probG=probG,lower=-Inf,upper=Inf)$value#
	y[2] <- integrate(f2,z=x,emm=emm,cond.means.X=cond.means.X,sdXgivenG=sdXgivenG,b0=b0,b1=b1,b2=b2,b3=b3,probG=probG,lower=-Inf,upper=Inf)$value#
	y[3] <- integrate(f3,z=x,emm=emm,cond.means.X=cond.means.X,sdXgivenG=sdXgivenG,b0=b0,b1=b1,b2=b2,b3=b3,probG=probG,lower=-Inf,upper=Inf)$value#
	y[4] <- integrate(f4,z=x,emm=emm,cond.means.X=cond.means.X,sdXgivenG=sdXgivenG,b0=b0,b1=b1,b2=b2,b3=b3,probG=probG,lower=-Inf,upper=Inf)$value#
	y#
}
score.eqs(x=rep(0.2,4), cond.means.X=cond_mean, sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3)
score.eqs(z=rep(0.2,4), cond.means.X=cond_mean, sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3)
score.eqs(x=c(0.2,0.2,0.2,0.2),cond.means.X=cond_mean, sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3))
score.eqs(x=c(0.2,0.2,0.2,0.2),cond.means.X=cond_mean, sdXgivenG=sdXgivenG, emm=function(x){x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3)
# the first integrand#
f1 <- function(X,emm,m,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * (expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * (expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * (expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the second integrand#
f2 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * (expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the third integrand#
f3 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * X*(expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the fourth integrand#
f4 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#####################################################################################
#####################################################################################
#####################################################################################
# Function that contains the system of equations we want to solve#
# x is the vector of solutions, we want y to be zero#
score.eqs <- function(x, cond.means.X, sdXgivenG, emm, b0, b1, b2, b3, probG){#
	y <- numeric(4)#
#
	y[1] <- integrate(f1,z=x,emm=emm,cond.means.X=cond.means.X,sdXgivenG=sdXgivenG,b0=b0,b1=b1,b2=b2,b3=b3,probG=probG,lower=-Inf,upper=Inf)$value#
	y[2] <- integrate(f2,z=x,emm=emm,cond.means.X=cond.means.X,sdXgivenG=sdXgivenG,b0=b0,b1=b1,b2=b2,b3=b3,probG=probG,lower=-Inf,upper=Inf)$value#
	y[3] <- integrate(f3,z=x,emm=emm,cond.means.X=cond.means.X,sdXgivenG=sdXgivenG,b0=b0,b1=b1,b2=b2,b3=b3,probG=probG,lower=-Inf,upper=Inf)$value#
	y[4] <- integrate(f4,z=x,emm=emm,cond.means.X=cond.means.X,sdXgivenG=sdXgivenG,b0=b0,b1=b1,b2=b2,b3=b3,probG=probG,lower=-Inf,upper=Inf)$value#
	y#
}
score.eqs(x=c(0.2,0.2,0.2,0.2),cond.means.X=cond_mean, sdXgivenG=sdXgivenG, emm=function(x){x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3)
# As f1 is the function to be integrated, the dimension of 'x' is the dimension #
# of integration and the variables represented by 'x' are what is being integrated.#
f1 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=alpha_vec[1]; alpha_G=alpha_vec[2]; alpha_X=alpha_vec[3]; alpha_I=alpha_vec[4];#
	dnorm(x, mean=0, sd=1) * expit(beta_0 + beta_X*x^2) - #
	dnorm(x, mean=cond_mean[1], sd=sd_X) * (1-p)^2 * expit(alpha_0 + alpha_X*x) - #
	dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(alpha_0 + alpha_G + alpha_X*x + alpha_I*x) - #
	dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(alpha_0 + 2*alpha_G + alpha_X*x + 2*alpha_I*x) #
}#
#
f2 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=alpha_vec[1]; alpha_G=alpha_vec[2]; alpha_X=alpha_vec[3]; alpha_I=alpha_vec[4];#
	dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(beta_0 + beta_X*x^2) - #
	dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(alpha_0 + alpha_G + alpha_X*x + alpha_I*x) + #
	2*dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(beta_0 + beta_X*x^2) - #
	2*dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(alpha_0 + 2*alpha_G + alpha_X*x + 2*alpha_I*x) #
}#
#
f3 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=alpha_vec[1]; alpha_G=alpha_vec[2]; alpha_X=alpha_vec[3]; alpha_I=alpha_vec[4];#
	x * dnorm(x, mean=0, sd=1) * expit(beta_0 + beta_X*x^2) - #
	x * dnorm(x, mean=cond_mean[1], sd=sd_X) * (1-p)^2 * expit(alpha_0 + alpha_X*x) - #
	x * dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(alpha_0 + alpha_G + alpha_X*x + alpha_I*x) - #
	x * dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(alpha_0 + 2*alpha_G + alpha_X*x + 2*alpha_I*x) #
}#
#
f4 <- function(x, alpha_vec, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_0=alpha_vec[1]; alpha_G=alpha_vec[2]; alpha_X=alpha_vec[3]; alpha_I=alpha_vec[4];#
	x * dnorm(x, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(beta_0 + beta_X*x^2) - #
	x * dnorm(x, mean=cond_mean[2], sd=sd_X) * 2*p*(1-p) * expit(alpha_0 + alpha_G + alpha_X*x + alpha_I*x) + #
	2 * x * dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(beta_0 + beta_X*x^2) - #
	2 * x * dnorm(x, mean=cond_mean[3], sd=sd_X) * p^2 * expit(alpha_0 + 2*alpha_G + alpha_X*x + 2*alpha_I*x) #
}
score_eqs_one <- function(x, p, cond_mean, sd_X, beta_0, beta_X)#
{#
	alpha_vec <- x#
	y <- numeric(4)#
	y[1] <- integrate(f=f1, lower=-Inf, upper=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)$value#
	y[2] <- integrate(f=f2, lower=-Inf, upper=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)$value#
	y[3] <- integrate(f=f3, lower=-Inf, upper=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)$value#
	y[4] <- integrate(f=f4, lower=-Inf, upper=Inf, #
			alpha_vec=alpha_vec, p=p, cond_mean=cond_mean, sd_X=sd_X, beta_0=beta_0, beta_X=beta_X)$value#
	y#
}
0.051499395 -0.002502604 -0.075714657 -0.037875931
score_eqs_one(x=rep(0.2,4), p=0.3, cond_mean=cond_mean, sd_X=sdXgivenG, beta_0=0.3, beta_X=0.3)
nleqslv(x=c(0,0,0,0), fn=score_eqs_one, p=0.3, cond_mean=cond_mean, sd_X=0.9539392, beta_0=-0.3, beta_X=0.3)
f1 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) - #
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}#
f2 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	dnorm(X, mean= cond.means.X[2], sd=sdXgivenG) * 2* probG*(1-probG) * expit(b0 + b2*X^2) - #
	dnorm(X, mean= cond.means.X[2], sd= sdXgivenG) * 2* probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2*dnorm(X, mean= cond.means.X[3], sd= sdXgivenG) * probG ^2 * expit(b0 + b2*X^2) - #
	2*dnorm(X, mean= cond.means.X[3], sd= sdXgivenG) * probG ^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}#
f3 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X*(dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) - #
	dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) )#
}#
f4 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(b0 + b2*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(b0 + b2*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
# the first integrand#
f1 <- function(X,emm,m,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * (expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * (expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * (expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the second integrand#
f2 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * (expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the third integrand#
f3 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * X*(expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the fourth integrand#
f4 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}
solved.coef
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
score.eqs
f1
f1 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) - #
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f1
f2 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	dnorm(X, mean= cond.means.X[2], sd=sdXgivenG) * 2* probG*(1-probG) * expit(b0 + b2*X^2) - #
	dnorm(X, mean= cond.means.X[2], sd= sdXgivenG) * 2* probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2*dnorm(X, mean= cond.means.X[3], sd= sdXgivenG) * probG ^2 * expit(b0 + b2*X^2) - #
	2*dnorm(X, mean= cond.means.X[3], sd= sdXgivenG) * probG ^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f4 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(b0 + b2*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(b0 + b2*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f3 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X*(dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) - #
	dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) )#
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
dnorm(X, mean=0, sd=1)#
dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 + #
dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) + #
dnorm(X, mean=cond.means.X[3], sd=sdXgivenG)* probG^2
cond.means.X
ell
X
probG
(1-probG)^2
2*probG*(1-probG)
probG^2
0.49 + 0.42 + 0.09
dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) *X#
(dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 + #
dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) + #
dnorm(X, mean=cond.means.X[3], sd=sdXgivenG)* probG^2 ) * expit(b0 + b2*X^2) *X
f3 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X*dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2* expit(b0 + b2*X^2) +#
	X*dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG)  * expit(b0 + b2*X^2) +#
	X*dnorm(X, mean=cond_mean[3], sd= sdXgivenG)  * probG^2 * expit(b0 + b2*X^2) -#
	dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) )#
}
f3 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X*dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2* expit(b0 + b2*X^2) +#
	X*dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG)  * expit(b0 + b2*X^2) +#
	X*dnorm(X, mean=cond_mean[3], sd= sdXgivenG)  * probG^2 * expit(b0 + b2*X^2) -#
	dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
# the third integrand#
f3 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * X*(expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}
solved.coef
# the first integrand#
f1 <- function(X,emm,m,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * (expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * (expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * (expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the second integrand#
f2 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * (expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the third integrand#
f3 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * X*(expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}#
#
# the fourth integrand#
f4 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f1 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	dnorm(X, mean=0, sd=1) * expit(b0 + b2*X^2) - #
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}#
f2 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	dnorm(X, mean= cond.means.X[2], sd=sdXgivenG) * 2* probG*(1-probG) * expit(b0 + b2*X^2) - #
	dnorm(X, mean= cond.means.X[2], sd= sdXgivenG) * 2* probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2*dnorm(X, mean= cond.means.X[3], sd= sdXgivenG) * probG ^2 * expit(b0 + b2*X^2) - #
	2*dnorm(X, mean= cond.means.X[3], sd= sdXgivenG) * probG ^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f4 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X * dnorm(X, mean=cond_mean[2], sd=1) * 2*p*(1-p) * expit(b0 + b2*X^2) - #
	X * dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) + #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(b0 + b2*X^2) - #
	2 * X * dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
# the fourth integrand#
f4 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z) {#
	dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * 2*X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f3 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X*dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2* expit(b0 + b2*X^2) +#
	X*dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG)  * expit(b0 + b2*X^2) +#
	X*dnorm(X, mean=cond_mean[3], sd= sdXgivenG)  * probG^2 * expit(b0 + b2*X^2) -#
	dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f3 <- function(X, emm, m, cond.means.X, sdXgivenG, b0, b1, b2, b3, probG, z)#
{#
	alpha_0=z[1]; alpha_G=z[2]; alpha_X=z[3]; alpha_I=z[4];#
	X*dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2* expit(b0 + b2*X^2) +#
	X*dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG)  * expit(b0 + b2*X^2) +#
	X*dnorm(X, mean=cond_mean[3], sd= sdXgivenG)  * probG^2 * expit(b0 + b2*X^2) -#
	X*dnorm(X, mean=cond_mean[1], sd= sdXgivenG) * (1-probG)^2 * expit(alpha_0 + alpha_X*X) - #
	X*dnorm(X, mean=cond_mean[2], sd= sdXgivenG) * 2*probG*(1-probG) * expit(alpha_0 + alpha_G + alpha_X*X + alpha_I*X) - #
	X*dnorm(X, mean=cond_mean[3], sd= sdXgivenG) * probG^2 * expit(alpha_0 + 2*alpha_G + alpha_X*X + 2*alpha_I*X) #
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
# the third integrand#
f3 <- function(X,emm,cond.means.X,sdXgivenG,b0,b1,b2,b3,probG,z)  {#
	dnorm(X, mean=cond.means.X[1], sd=sdXgivenG) * (1-probG)^2 * X*(expit(b0+b2*emm(X))-expit(z[1]+z[3]*X)) + dnorm(X, mean=cond.means.X[2], sd=sdXgivenG) * 2*probG*(1-probG) * X*(expit(b0+b1+b2*emm(X)+b3*X)-expit(z[1]+z[2]+z[3]*X+z[4]*X)) + dnorm(X, mean=cond.means.X[3], sd=sdXgivenG) * probG^2 * X*(expit(b0+2*b1+b2*emm(X)+2*b3*X)-expit(z[1]+2*z[2]+z[3]*X+2*z[4]*X))#
}
solved.coef <- nleqslv(x=xstart, fn=score.eqs, cond.means.X=cond.means.X,sdXgivenG=sdXgivenG, emm=function(x) {x^2}, b0=0.3, b1=0, b2=0.3, b3=0, probG=0.3, control=list(btol=.00000000001))$x
solved.coef
f3
setwd('/users/ryansun/documents/research/paper2/software/geint/R')
setwd('/users/ryansun/documents/research/paper2/software/geint')
install("GEint")
library(devtools)
library(roxygen2)
install("GEint")
setwd('/users/ryansun/documents/research/paper2/software')
install("GEint")
install("GEint")
install("GEint")
install("GEint")
library(nleqslv)
library(mvtnorm)
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_Z <- NULL#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_W <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_W <- NULL#
}#
#
# Test first#
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
GE_bias
library(GEint)
GE_Bias
GE_Bias
GE_neqlslv
GE_bias_normal_squaredmis
GE_bias
GE_bias
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
num_Z <- rpois(n=1, lambda=1)#
if (num_Z==0) {num_Z <- 1}#
num_W <- rpois(n=1, lambda=1)#
if (num_W==0) {num_W <- 1}#
beta_list <- list( runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=1, min=0.1, max=1),#
				runif(n=num_Z, min=0.1, max=1),#
				runif(n=num_W, min=0.1, max=1)	)#
#
rho_list <- list( runif(n=1, min=0.02, max=0.3),#
					 runif(n=num_Z, min=0.02, max=0.3),#
					  runif(n=num_Z, min=0.02, max=0.3),#
					   runif(n=num_W, min=0.02, max=0.3),#
					    runif(n=num_W, min=0.02, max=0.3),#
					     runif(n=num_W*num_Z, min=0.02, max=0.3) )#
#
prob_G = runif(n=1, min=0.05, max=0.95)#
#
if (num_Z > 1) {#
	temp <- num_Z*(num_Z-1) / 2#
	cov_Z <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_Z <- NULL#
}#
#
if (num_W > 1) {#
	temp <- num_W*(num_W-1) / 2#
	cov_W <- runif(n=temp, min=0.02, max=0.2)#
} else {#
	cov_W <- NULL#
}#
#
# Test first#
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
library(pracma)
GE_test_moments_calcs(beta_list, rho_list, prob_G, cov_Z, cov_W)
sim_results <- GE_scoreeq_sim(beta_list=beta_list, prob_G=prob_G, rho_list=rho_list, cov_Z=cov_Z, cov_W=cov_W)
solve_results <- GE_bias_normal_squaredmis(beta_list, rho_list, prob_G, cov_Z, cov_W)
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )#
#
cov_list <- solve_results$cov_list#
HOM_list <- solve_results$HOM_list#
cov_mat_list <- list( MU_ZZ=solve_results$MU_ZZ, MU_WW=solve_results$MU_WW, MU_ZW=solve_results$MU_ZW,#
					MU_WZ=solve_results$MU_WZ, MU_ZM=solve_results$MU_ZM, MU_WM=solve_results$MU_WM)#
#
nleqslv_results <- GE_nleqslv(beta_list, cov_list, cov_mat_list, mu_list, HOM_list)
ge_bias_results <- GE_bias(beta_list, cov_list, cov_mat_list, mu_list, HOM_list)
# Should all match#
nleqslv_results$x#
sim_results#
solve_results$alpha_list#
ge_bias_results
?GE_bias
list(runif(n=6))
list(rep(runif(n=1), 6))
as.list(runif(n=6))
GE_nleqslv
setwd('/users/ryansun/documents/research/paper2/software/geint/R')
beta_list <- list(1, 1, 1, 0, c(1,1), 1)#
rho_list <- list(0.1, c(0.1, 0.1), c(0.1,0.1), 1, 1, c(0.1, 0.1))#
prob_G <- 0.3#
cov_Z <- 0.1#
cov_W <- NULL#
normal_assumptions <- GE_bias_normal_squaredmis(beta_list=beta_list, rho_list=rho_list, prob_G=prob_G, cov_Z=cov_Z)
# First, make sure we got good inputs#
  	if (length(beta_list) != 6 | length(rho_list) != 6 | class(beta_list) != 'list' | class(rho_list) != 'list')#
  	{#
  	  stop('Input vectors not the right size!')#
  	}#
#
	# How long are these vectors?  Remember that W is the same length as M by assumption.#
  	num_Z <- length(beta_list[[5]])#
  	num_W <- length(beta_list[[6]])#
  	num_rho <- 2*(num_Z+num_W) + num_Z*num_W + 1#
  	# Make sure we have compatible lengths for rho_list#
    if (length(rho_list[[2]]) != num_Z | length(rho_list[[3]]) != num_Z | length(rho_list[[4]]) != num_W#
   			| length(rho_list[[5]]) != num_W | length(rho_list[[6]]) != num_Z*num_W) {#
   		stop('Incompatible number of elements in beta/rho_list')#
   	}#
   	# Fill in our covariances.#
   	rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
   	rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
   	#################################################################
    # Build our covariance matrix in steps.#
    # The 3x3 in the top left is always the same to build, vectors or not.#
    w <- qnorm(1-prob_G)					# Threshold for generating G#
    r_GE <- rho_GE / (2*dnorm(w))	#
    sig_mat_GE <- matrix(data=c(1, 0, r_GE, 0, 1, r_GE, r_GE, r_GE, 1), nrow=3) #
    # Build the p*3 matrix that describes Z with G1,G2,E#
    sig_mat_Z_column <- matrix(data=NA, nrow=num_Z, ncol=3)#
    r_GZ <- rho_GZ / (2*dnorm(w))#
    for (i in 1:num_Z) {#
    	sig_mat_Z_column[i,] <- c(r_GZ[i], r_GZ[i], rho_EZ[i])#
    }#
    # Build the q*3 matrix that describes W with G1,G2,E#
    sig_mat_W_column <- matrix(data=NA, nrow=num_W, ncol=3)#
    r_GW <- rho_GW / (2*dnorm(w))#
    for (i in 1:num_W) {#
    	sig_mat_W_column[i,] <- c(r_GW[i], r_GW[i], rho_EW[i])#
    }#
    # Build the p*q matrix that describes Z with W#
    sig_mat_Z_W <- matrix(data=NA, nrow=num_Z, ncol=num_W)#
    for (i in 1:num_Z) {#
    	start_ind <- (i-1)*num_W+1#
    	end_ind <- i*num_W#
    	sig_mat_Z_W[i,] <- rho_ZW[start_ind:end_ind]#
    }#
    # If Z or W vectorized, build the ZZ and WW covariance matrices too#
    if (num_Z > 1) {#
    	sig_mat_ZZ <- matrix(data=0, nrow=num_Z, ncol=num_Z)#
    	sig_mat_ZZ[upper.tri(sig_mat_ZZ)] <- cov_Z#
    	sig_mat_ZZ <- sig_mat_ZZ + t(sig_mat_ZZ)#
    	diag(sig_mat_ZZ) <- 1#
    } else {#
    	sig_mat_ZZ <- matrix(data=1, nrow=1, ncol=1)#
    }#
    if (num_W > 1) {#
    	sig_mat_WW <- matrix(data=0, nrow=num_W, ncol=num_W)#
    	sig_mat_WW[upper.tri(sig_mat_WW)] <- cov_W#
    	sig_mat_WW <- sig_mat_WW + t(sig_mat_WW)#
    	diag(sig_mat_WW) <- 1#
    } else {#
    	sig_mat_WW <- matrix(data=1, nrow=1, ncol=1)#
    }#
    # Now put it all together#
    sig_mat_total <- matrix(data=NA, nrow=(3+num_Z+num_W), ncol=(3+num_Z+num_W))#
    sig_mat_total[1:3, 1:3] <- sig_mat_GE#
    sig_mat_total[4:(3+num_Z), 1:3] <- sig_mat_Z_column#
    sig_mat_total[1:3, 4:(3+num_Z)] <- t(sig_mat_Z_column)#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 1:3] <- sig_mat_W_column#
    sig_mat_total[1:3, (4+num_Z):(3+num_Z+num_W)] <- t(sig_mat_W_column)#
    sig_mat_total[4:(3+num_Z), 4:(3+num_Z)] <- sig_mat_ZZ#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_WW#
    sig_mat_total[4:(3+num_Z), (4+num_Z):(3+num_Z+num_W)] <- sig_mat_Z_W#
    sig_mat_total[(4+num_Z):(3+num_Z+num_W), 4:(3+num_Z)] <- t(sig_mat_Z_W)#
    if (!isSymmetric(sig_mat_total)) {stop("Problem building covariance matrix!")}
# Now make sure we can actually generate data with this structure#
    test_data <- tryCatch(mvtnorm::rmvnorm(n=1, sigma=sig_mat_total), #
    				warning=function(w) w, error=function(e) e)#
    if (class(test_data)[1] != 'matrix') {stop('You specified an impossible covariance matrix!')}
test_data
sigma-
sigma
sig_mat_total
sig_mat_Z_column
sig_mat_W_column
rho_EW
rho_list
beta_list <- list(1, 1, 1, 0, c(1,1), 1)#
rho_list <- list(0.1, c(0.1, 0.1), c(0.1,0.1), 0.1, 0.1, c(0.1, 0.1))#
prob_G <- 0.3#
cov_Z <- 0.1#
cov_W <- NULL#
normal_assumptions <- GE_bias_normal_squaredmis(beta_list=beta_list, rho_list=rho_list, prob_G=prob_G, cov_Z=cov_Z)
beta_list <- list(1, 1, 1, 0, c(1,1), 1)#
rho_list <- list(0.1, c(0.1, 0.1), c(0.1,0.1), 0.1, 0.1, c(0.1, 0.1))#
prob_G <- 0.3#
cov_Z <- 0.1#
cov_W <- NULL#
normal_assumptions <- GE_bias_normal_squaredmis(beta_list=beta_list, rho_list=rho_list, prob_G=prob_G, cov_Z=cov_Z)#
```
normal_assumptions
cov_list <- normal_assumptions$cov_list#
cov_mat_list <- normal_assumptions$cov_mat_list#
mu_list <- normal_assumptions$mu_list#
HOM_list <- normal_assumptions$HOM_list
no_assumptions <- GE_bias(beta_list, cov_list, cov_mat_list, mu_list, HOM_list)
mu_list
mu_list <- list( solve_results$mu_list[[1]], solve_results$mu_list[[2]],	#
				solve_results$mu_list[[3]],rep(0, num_Z), rep(0, num_W) )
no_assumptions <- GE_bias(beta_list, cov_list, cov_mat_list, mu_list, HOM_list)
# Record some initial quantities#
  beta_0 <- beta_list[[1]]; beta_G <- beta_list[[2]]; beta_E <- beta_list[[3]]#
  beta_I <- beta_list[[4]]; BETA_Z <- beta_list[[5]]; BETA_M <- beta_list[[6]]#
  # Some means#
  mu_f <- mu_list[[1]]; mu_h <- mu_list[[2]]; MU_Z <- mu_list[[3]]#
  MU_M <- mu_list[[4]]; MU_W <- mu_list[[5]]#
  # Some covariances#
  mu_GG <- cov_list[[1]]#
  mu_GE <- cov_list[[2]]#
  mu_Gf <- cov_list[[3]]#
  mu_Gh <- cov_list[[4]]#
  MU_GZ <- cov_list[[5]] #
  MU_GM <- cov_list[[6]]#
  MU_GW <- cov_list[[7]]#
  mu_EE <- cov_list[[8]]#
  mu_Ef <- cov_list[[9]]#
  MU_EZ <- cov_list[[10]]#
  MU_EM <- cov_list[[11]] #
  MU_EW <- cov_list[[12]]#
  MU_fZ <- cov_list[[13]] #
  MU_fW <- cov_list[[14]]#
  #########################
  # Matrix covariances#
  # MU_ZW is not the same as MU_WZ because the dimensions of the matrix are not the same!#
  MU_ZZ <- cov_mat_list[[1]]#
  MU_WW <- cov_mat_list[[2]]#
  MU_ZW <- cov_mat_list[[3]]#
  MU_WZ <- cov_mat_list[[4]]#
  MU_ZM <- cov_mat_list[[5]]	#
  MU_WM <- cov_mat_list[[6]]			#
  # Some higher order moments#
  mu_GGE <- HOM_list[[1]]#
  mu_GGh <- HOM_list[[2]]#
  mu_GEE <- HOM_list[[3]]#
  mu_GEf <- HOM_list[[4]]#
  mu_GEh <- HOM_list[[5]]#
  MU_GEZ <- HOM_list[[6]]#
  MU_GEM <- HOM_list[[7]]#
  MU_GEW <- HOM_list[[8]]#
  MU_GhW <- HOM_list[[9]]#
  MU_GhZ <- HOM_list[[10]]#
  mu_GGEE <- HOM_list[[11]]#
  mu_GGEf <- HOM_list[[12]]#
  mu_GGEh <- HOM_list[[13]]#
  #########################
  # Some shortcut quantities#
  A <- (mu_GE * MU_GZ / mu_GG - MU_EZ) / (mu_EE - mu_GE^2/mu_GG)#
  B <- (mu_GE * MU_GW / mu_GG - MU_EW) / (mu_EE - mu_GE^2/mu_GG)#
  O <- MU_Z%*%t(MU_Z) + MU_GZ%*%t(MU_GZ)/mu_GG - MU_ZZ - A %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG)#
  C <- (B %*% t(MU_EZ - MU_GZ*mu_GE/mu_GG) - MU_W%*%t(MU_Z) - MU_GW%*%t(MU_GZ)/mu_GG + MU_WZ) %*% solve(O)#
  Q <- MU_W%*%t(MU_W) + MU_GW%*%t(MU_GW)/mu_GG - MU_WW + B %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + #
    C %*% ( MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW + A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) )#
  D <- (mu_GE * mu_GGE / mu_GG - mu_GEE) / (mu_EE - mu_GE^2 / mu_GG)#
  E <- t(MU_GEZ - MU_Z*mu_GE - MU_GZ*mu_GGE/mu_GG + D*(MU_EZ - MU_GZ*mu_GE/mu_GG)) %*% solve(O)#
  EFF <- ( t(MU_W*mu_GE + MU_GW*mu_GGE/mu_GG - MU_GEW + D*(MU_GW * mu_GE / mu_GG - MU_EW)) + #
             E %*% (A %*% t(MU_GW*mu_GE/mu_GG - MU_EW) + MU_Z%*%t(MU_W) + MU_GZ%*%t(MU_GW)/mu_GG - MU_ZW) ) %*% solve(Q)
MU_Z
MU_Z%*%t(MU_Z) + MU_GZ%*%t(MU_GZ)/mu_GG - MU_ZZ
MU_GZ%*%t(MU_GZ)/mu_GG
MU_Z
beta_list
nu_Z
num_Z
mu_list
surv <- function(x) {1-pnorm(x)}#
  # Record some initial quantities#
  rho_GE <- rho_list[[1]]; rho_GZ <- rho_list[[2]]; rho_EZ <- rho_list[[3]]#
  rho_GW <- rho_list[[4]]; rho_EW <- rho_list[[5]]; rho_ZW <- rho_list[[6]]#
  w <- qnorm(1-prob_G)					#
  r_GE <- rho_GE / (2*dnorm(w))	#
  r_GZ <- rho_GZ / (2*dnorm(w))#
  r_GW <- rho_GW / (2*dnorm(w))#
  num_Z <- length(beta_list[[5]])#
  num_W <- length(beta_list[[6]])
num_
num_Z
num_W
library(speedglm)
library(rje)
library(geepack)
#' GE_BICS.R#
#'#
#' A function to perform inference on the GxE interaction regression coefficient.#
#' Shows better small sample performance than comparable methods.#
#' #
#' @param outcome The outcome vector#
#' @param design_mat The design matrix of covariates#
#' @param num_boots The number of bootstrap resamples to perform - we suggest 1000#
#' @param desired_coef The column in the design matrix holding the interaction covariate#
#' @param outcome_type Either 'D' for dichotomous outcome or 'C' for continuous outcome#
#' #
#' @return The p-value for the interaction effect#
#'#
#' @keywords#
#' @export#
#' @examples #
#' E <- rnorm(n=500)#
#' G <- rbinom(n=500, size=2, prob=0.3)#
#' design_mat <- cbind(1, G, E, G*E)#
#' outcome <- rnorm(500)#
#' GE_BICS(outcome=outcome, design_mat=design_mat, desired_coef=4, outcome_type='C')#
#
GE_BICS <- function(outcome, design_mat, num_boots=1000, desired_coef, outcome_type)#
{#
	# Fit the initial mod#
	n <- length(outcome)#
	if (outcome_type == 'C') {#
		init_mod <- geepack:geeglm(outcome~design_mat - 1, id=1:n)#
	} else if (outcome_type == 'D') {#
		init_mod <- geepack:geeglm(outcome~design_mat - 1, family=binomial(link='logit'), id=1:n)#
	} else {#
		stop('Invalid outcome type!')#
	}#
	beta_init <- summary(init_mod)$coefficients[desired_coef,1]#
	se_init <- summary(init_mod)$coefficients[desired_coef,2]#
#
	# Bootstrapping#
	b_vec <- rep(NA, num_boots)#
	z_vec <- rep(NA, num_boots)#
	for (i in 1:num_boots)#
	{#
		# Get bootstrap samples#
		samp_index <- sample(1:n, size=n, replace=TRUE)#
		temp_Y <- outcome[samp_index]#
		temp_X <- design_mat[samp_index,]#
		# If n small, need to check and make sure we can do the fitting/d_mat nonsingular.#
		# This runs fast when n small so ok to use a little more computing power.#
		if (n <= 500)#
		{#
			svd_min <- svd(temp_X)$d[ncol(temp_X)]#
			if (svd_min < 10^(-4)) {next}#
		} #
		# Get the sandwich estimator fast#
		if (outcome_type == 'C') {#
			bread <- solve(crossprod(temp_X))#
			b_hat <- ( bread %*% crossprod(temp_X,temp_Y) )#
			fit_y <- temp_X %*% b_hat#
			resid_sq <- as.numeric( (temp_Y - fit_y)^2 )#
			meat <- crossprod(temp_X * resid_sq, temp_X)#
			b_k <- b_hat[desired_coef]#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )	#
		} else {#
			boot_mod <- tryCatch(speedglm::speedglm.wfit(y=temp_Y, X=temp_X, family=binomial()), #
				warning=function(w) w, error=function(e) e)#
			if (length(class(boot_mod)) > 1) {next}#
			fitted <- as.numeric( expit( temp_X %*% boot_mod$coefficients ) )#
			bread <- solve( crossprod(temp_X * fitted * (1-fitted), temp_X) )#
			meat <- crossprod(temp_X*(temp_Y-fitted)^2, temp_X)#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )#
			b_k <- boot_mod$coefficients[desired_coef]#
		}#
		b_vec[i] <- b_k#
		z_vec[i] <- ((b_k-beta)/s_k)^2#
	}#
	# Match moments#
	mean_Z <- mean(z_vec, na.rm=TRUE)#
	var_Z <- var(z_vec, na.rm=TRUE)#
	cee <- var_Z / (2*mean_Z)#
	a <- mean_Z / cee#
	# Calculate p-value#
	test_stat <- (beta_init / sand_init)^2 / cee#
	p_value <- 1-pgamma(test_stat, shape=a/2, scale=2)#
	return( p_value )#
}
GE_BICS(outcome=Y, design_mat=design_mat, desired_coef=4, outcome_type='C')
# Test GE_BICS()#
set.seed(100)#
n <- 500#
Y <- rnorm(n=n)#
E <- rnorm(n=n)#
G <- rbinom(n=n, size=2, prob=0.3)#
design_mat <- cbind(1, G, E, G*E)#
GE_BICS(outcome=Y, design_mat=design_mat, desired_coef=4, outcome_type='C')
library(geepack)
#' GE_BICS.R#
#'#
#' A function to perform inference on the GxE interaction regression coefficient.#
#' Shows better small sample performance than comparable methods.#
#' #
#' @param outcome The outcome vector#
#' @param design_mat The design matrix of covariates#
#' @param num_boots The number of bootstrap resamples to perform - we suggest 1000#
#' @param desired_coef The column in the design matrix holding the interaction covariate#
#' @param outcome_type Either 'D' for dichotomous outcome or 'C' for continuous outcome#
#' #
#' @return The p-value for the interaction effect#
#'#
#' @keywords#
#' @export#
#' @examples #
#' E <- rnorm(n=500)#
#' G <- rbinom(n=500, size=2, prob=0.3)#
#' design_mat <- cbind(1, G, E, G*E)#
#' outcome <- rnorm(500)#
#' GE_BICS(outcome=outcome, design_mat=design_mat, desired_coef=4, outcome_type='C')#
#
GE_BICS <- function(outcome, design_mat, num_boots=1000, desired_coef, outcome_type)#
{#
	# Fit the initial mod#
	n <- length(outcome)#
	if (outcome_type == 'C') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, id=1:n)#
	} else if (outcome_type == 'D') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, family=binomial(link='logit'), id=1:n)#
	} else {#
		stop('Invalid outcome type!')#
	}#
	beta_init <- summary(init_mod)$coefficients[desired_coef,1]#
	se_init <- summary(init_mod)$coefficients[desired_coef,2]#
#
	# Bootstrapping#
	b_vec <- rep(NA, num_boots)#
	z_vec <- rep(NA, num_boots)#
	for (i in 1:num_boots)#
	{#
		# Get bootstrap samples#
		samp_index <- sample(1:n, size=n, replace=TRUE)#
		temp_Y <- outcome[samp_index]#
		temp_X <- design_mat[samp_index,]#
		# If n small, need to check and make sure we can do the fitting/d_mat nonsingular.#
		# This runs fast when n small so ok to use a little more computing power.#
		if (n <= 500)#
		{#
			svd_min <- svd(temp_X)$d[ncol(temp_X)]#
			if (svd_min < 10^(-4)) {next}#
		} #
		# Get the sandwich estimator fast#
		if (outcome_type == 'C') {#
			bread <- solve(crossprod(temp_X))#
			b_hat <- ( bread %*% crossprod(temp_X,temp_Y) )#
			fit_y <- temp_X %*% b_hat#
			resid_sq <- as.numeric( (temp_Y - fit_y)^2 )#
			meat <- crossprod(temp_X * resid_sq, temp_X)#
			b_k <- b_hat[desired_coef]#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )	#
		} else {#
			boot_mod <- tryCatch(speedglm::speedglm.wfit(y=temp_Y, X=temp_X, family=binomial()), #
				warning=function(w) w, error=function(e) e)#
			if (length(class(boot_mod)) > 1) {next}#
			fitted <- as.numeric( expit( temp_X %*% boot_mod$coefficients ) )#
			bread <- solve( crossprod(temp_X * fitted * (1-fitted), temp_X) )#
			meat <- crossprod(temp_X*(temp_Y-fitted)^2, temp_X)#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )#
			b_k <- boot_mod$coefficients[desired_coef]#
		}#
		b_vec[i] <- b_k#
		z_vec[i] <- ((b_k-beta)/s_k)^2#
	}#
	# Match moments#
	mean_Z <- mean(z_vec, na.rm=TRUE)#
	var_Z <- var(z_vec, na.rm=TRUE)#
	cee <- var_Z / (2*mean_Z)#
	a <- mean_Z / cee#
	# Calculate p-value#
	test_stat <- (beta_init / sand_init)^2 / cee#
	p_value <- 1-pgamma(test_stat, shape=a/2, scale=2)#
	return( p_value )#
}
# Test GE_BICS()#
set.seed(100)#
n <- 500#
Y <- rnorm(n=n)#
E <- rnorm(n=n)#
G <- rbinom(n=n, size=2, prob=0.3)#
design_mat <- cbind(1, G, E, G*E)#
GE_BICS(outcome=Y, design_mat=design_mat, desired_coef=4, outcome_type='C')
outcome=Y
desired_coef=4
outcome_type='C'
# Fit the initial mod#
	n <- length(outcome)#
	if (outcome_type == 'C') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, id=1:n)#
	} else if (outcome_type == 'D') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, family=binomial(link='logit'), id=1:n)#
	} else {#
		stop('Invalid outcome type!')#
	}#
	beta_init <- summary(init_mod)$coefficients[desired_coef,1]#
	se_init <- summary(init_mod)$coefficients[desired_coef,2]
n <- length(outcome)
init_mod <- geepack::geeglm(outcome~design_mat - 1, id=1:n)
geeglm(outcome~design_mat-1, id=1:n)
summary(init_mod)$coefficients
summary(init_mod)
init_mod
init_mod$coefficients
design_mat
summary(init_mod)
outcome
init_mod$ceofficients
init_mod$coefficients
colnames(design_mat)
colnames(design_mat) <- 1:4
init_mod <- geepack::geeglm(outcome~design_mat - 1, id=1:n)
summary(init_mod)
summary(init_mod)$coefficients
# Fit the initial mod#
	n <- length(outcome)#
	if (outcome_type == 'C') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, id=1:n, std.err='san.se')#
	} else if (outcome_type == 'D') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, family=binomial(link='logit'), 	#
				id=1:n, std.err='san.se')#
	} else {#
		stop('Invalid outcome type!')#
	}#
	beta_init <- summary(init_mod)$coefficients[desired_coef,1]#
	se_init <- summary(init_mod)$coefficients[desired_coef,2]
beta_init
se_init
# Bootstrapping#
	b_vec <- rep(NA, num_boots)#
	z_vec <- rep(NA, num_boots)#
	for (i in 1:num_boots)#
	{#
		# Get bootstrap samples#
		samp_index <- sample(1:n, size=n, replace=TRUE)#
		temp_Y <- outcome[samp_index]#
		temp_X <- design_mat[samp_index,]#
		# If n small, need to check and make sure we can do the fitting/d_mat nonsingular.#
		# This runs fast when n small so ok to use a little more computing power.#
		if (n <= 500)#
		{#
			svd_min <- svd(temp_X)$d[ncol(temp_X)]#
			if (svd_min < 10^(-4)) {next}#
		} #
		# Get the sandwich estimator fast#
		if (outcome_type == 'C') {#
			bread <- solve(crossprod(temp_X))#
			b_hat <- ( bread %*% crossprod(temp_X,temp_Y) )#
			fit_y <- temp_X %*% b_hat#
			resid_sq <- as.numeric( (temp_Y - fit_y)^2 )#
			meat <- crossprod(temp_X * resid_sq, temp_X)#
			b_k <- b_hat[desired_coef]#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )	#
		} else {#
			boot_mod <- tryCatch(speedglm::speedglm.wfit(y=temp_Y, X=temp_X, family=binomial()), #
				warning=function(w) w, error=function(e) e)#
			if (length(class(boot_mod)) > 1) {next}#
			fitted <- as.numeric( expit( temp_X %*% boot_mod$coefficients ) )#
			bread <- solve( crossprod(temp_X * fitted * (1-fitted), temp_X) )#
			meat <- crossprod(temp_X*(temp_Y-fitted)^2, temp_X)#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )#
			b_k <- boot_mod$coefficients[desired_coef]#
		}#
		b_vec[i] <- b_k#
		z_vec[i] <- ((b_k-beta)/s_k)^2#
	}#
	# Match moments#
	mean_Z <- mean(z_vec, na.rm=TRUE)#
	var_Z <- var(z_vec, na.rm=TRUE)#
	cee <- var_Z / (2*mean_Z)#
	a <- mean_Z / cee
num_boots=1000
# Bootstrapping#
	b_vec <- rep(NA, num_boots)#
	z_vec <- rep(NA, num_boots)#
	for (i in 1:num_boots)#
	{#
		# Get bootstrap samples#
		samp_index <- sample(1:n, size=n, replace=TRUE)#
		temp_Y <- outcome[samp_index]#
		temp_X <- design_mat[samp_index,]#
		# If n small, need to check and make sure we can do the fitting/d_mat nonsingular.#
		# This runs fast when n small so ok to use a little more computing power.#
		if (n <= 500)#
		{#
			svd_min <- svd(temp_X)$d[ncol(temp_X)]#
			if (svd_min < 10^(-4)) {next}#
		} #
		# Get the sandwich estimator fast#
		if (outcome_type == 'C') {#
			bread <- solve(crossprod(temp_X))#
			b_hat <- ( bread %*% crossprod(temp_X,temp_Y) )#
			fit_y <- temp_X %*% b_hat#
			resid_sq <- as.numeric( (temp_Y - fit_y)^2 )#
			meat <- crossprod(temp_X * resid_sq, temp_X)#
			b_k <- b_hat[desired_coef]#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )	#
		} else {#
			boot_mod <- tryCatch(speedglm::speedglm.wfit(y=temp_Y, X=temp_X, family=binomial()), #
				warning=function(w) w, error=function(e) e)#
			if (length(class(boot_mod)) > 1) {next}#
			fitted <- as.numeric( expit( temp_X %*% boot_mod$coefficients ) )#
			bread <- solve( crossprod(temp_X * fitted * (1-fitted), temp_X) )#
			meat <- crossprod(temp_X*(temp_Y-fitted)^2, temp_X)#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )#
			b_k <- boot_mod$coefficients[desired_coef]#
		}#
		b_vec[i] <- b_k#
		z_vec[i] <- ((b_k-beta)/s_k)^2#
	}#
	# Match moments#
	mean_Z <- mean(z_vec, na.rm=TRUE)#
	var_Z <- var(z_vec, na.rm=TRUE)#
	cee <- var_Z / (2*mean_Z)#
	a <- mean_Z / cee
b_k
# Bootstrapping#
	b_vec <- rep(NA, num_boots)#
	z_vec <- rep(NA, num_boots)#
	for (i in 1:num_boots)#
	{#
		# Get bootstrap samples#
		samp_index <- sample(1:n, size=n, replace=TRUE)#
		temp_Y <- outcome[samp_index]#
		temp_X <- design_mat[samp_index,]#
		# If n small, need to check and make sure we can do the fitting/d_mat nonsingular.#
		# This runs fast when n small so ok to use a little more computing power.#
		if (n <= 500)#
		{#
			svd_min <- svd(temp_X)$d[ncol(temp_X)]#
			if (svd_min < 10^(-4)) {next}#
		} #
		# Get the sandwich estimator fast#
		if (outcome_type == 'C') {#
			bread <- solve(crossprod(temp_X))#
			b_hat <- ( bread %*% crossprod(temp_X,temp_Y) )#
			fit_y <- temp_X %*% b_hat#
			resid_sq <- as.numeric( (temp_Y - fit_y)^2 )#
			meat <- crossprod(temp_X * resid_sq, temp_X)#
			b_k <- b_hat[desired_coef]#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )	#
		} else {#
			boot_mod <- tryCatch(speedglm::speedglm.wfit(y=temp_Y, X=temp_X, family=binomial()), #
				warning=function(w) w, error=function(e) e)#
			if (length(class(boot_mod)) > 1) {next}#
			fitted <- as.numeric( expit( temp_X %*% boot_mod$coefficients ) )#
			bread <- solve( crossprod(temp_X * fitted * (1-fitted), temp_X) )#
			meat <- crossprod(temp_X*(temp_Y-fitted)^2, temp_X)#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )#
			b_k <- boot_mod$coefficients[desired_coef]#
		}#
		b_vec[i] <- b_k#
		z_vec[i] <- ((b_k-beta_init)/s_k)^2#
	}#
	# Match moments#
	mean_Z <- mean(z_vec, na.rm=TRUE)#
	var_Z <- var(z_vec, na.rm=TRUE)#
	cee <- var_Z / (2*mean_Z)#
	a <- mean_Z / cee
cee
a
# Calculate p-value#
	test_stat <- (beta_init / sand_init)^2 / cee#
	p_value <- 1-pgamma(test_stat, shape=a/2, scale=2)
# Calculate p-value#
	test_stat <- (beta_init / se_init)^2 / cee#
	p_value <- 1-pgamma(test_stat, shape=a/2, scale=2)
p_value
summary(init_mod)
Y <- rbinom(n=500, size=1, prob=0.5)
#' GE_BICS.R#
#'#
#' A function to perform inference on the GxE interaction regression coefficient.#
#' Shows better small sample performance than comparable methods.#
#' #
#' @param outcome The outcome vector#
#' @param design_mat The design matrix of covariates#
#' @param num_boots The number of bootstrap resamples to perform - we suggest 1000#
#' @param desired_coef The column in the design matrix holding the interaction covariate#
#' @param outcome_type Either 'D' for dichotomous outcome or 'C' for continuous outcome#
#' #
#' @return The p-value for the interaction effect#
#'#
#' @keywords#
#' @export#
#' @examples #
#' E <- rnorm(n=500)#
#' G <- rbinom(n=500, size=2, prob=0.3)#
#' design_mat <- cbind(1, G, E, G*E)#
#' outcome <- rnorm(500)#
#' GE_BICS(outcome=outcome, design_mat=design_mat, desired_coef=4, outcome_type='C')#
#
GE_BICS <- function(outcome, design_mat, num_boots=1000, desired_coef, outcome_type)#
{#
	colnames(design_mat) <- 1:ncol(design_mat)#
	n <- length(outcome)#
	# Fit the initial mod#
	if (outcome_type == 'C') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, id=1:n, std.err='san.se')#
	} else if (outcome_type == 'D') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, family=binomial(link='logit'), 	#
				id=1:n, std.err='san.se')#
	} else {#
		stop('Invalid outcome type!')#
	}#
	beta_init <- summary(init_mod)$coefficients[desired_coef,1]#
	se_init <- summary(init_mod)$coefficients[desired_coef,2]#
#
	# Bootstrapping#
	b_vec <- rep(NA, num_boots)#
	z_vec <- rep(NA, num_boots)#
	for (i in 1:num_boots)#
	{#
		# Get bootstrap samples#
		samp_index <- sample(1:n, size=n, replace=TRUE)#
		temp_Y <- outcome[samp_index]#
		temp_X <- design_mat[samp_index,]#
		# If n small, need to check and make sure we can do the fitting/d_mat nonsingular.#
		# This runs fast when n small so ok to use a little more computing power.#
		if (n <= 500)#
		{#
			svd_min <- svd(temp_X)$d[ncol(temp_X)]#
			if (svd_min < 10^(-4)) {next}#
		} #
		# Get the sandwich estimator fast#
		if (outcome_type == 'C') {#
			bread <- solve(crossprod(temp_X))#
			b_hat <- ( bread %*% crossprod(temp_X,temp_Y) )#
			fit_y <- temp_X %*% b_hat#
			resid_sq <- as.numeric( (temp_Y - fit_y)^2 )#
			meat <- crossprod(temp_X * resid_sq, temp_X)#
			b_k <- b_hat[desired_coef]#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )	#
		} else {#
			boot_mod <- tryCatch(speedglm::speedglm.wfit(y=temp_Y, X=temp_X, family=binomial()), #
				warning=function(w) w, error=function(e) e)#
			if (length(class(boot_mod)) > 1) {next}#
			fitted <- as.numeric( expit( temp_X %*% boot_mod$coefficients ) )#
			bread <- solve( crossprod(temp_X * fitted * (1-fitted), temp_X) )#
			meat <- crossprod(temp_X*(temp_Y-fitted)^2, temp_X)#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )#
			b_k <- boot_mod$coefficients[desired_coef]#
		}#
		b_vec[i] <- b_k#
		z_vec[i] <- ((b_k-beta_init)/s_k)^2#
	}#
	# Match moments#
	mean_Z <- mean(z_vec, na.rm=TRUE)#
	var_Z <- var(z_vec, na.rm=TRUE)#
	cee <- var_Z / (2*mean_Z)#
	a <- mean_Z / cee#
	# Calculate p-value#
	test_stat <- (beta_init / se_init)^2 / cee#
	p_value <- 1-pgamma(test_stat, shape=a/2, scale=2)#
	return( p_value )#
}
GE_BICS(outcome=Y, design_mat=design_mat, desired_coef=4, outcome_type='D')
outcome=Y
colnames(design_mat) <- 1:ncol(design_mat)#
	n <- length(outcome)#
	# Fit the initial mod#
	if (outcome_type == 'C') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, id=1:n, std.err='san.se')#
	} else if (outcome_type == 'D') {#
		init_mod <- geepack::geeglm(outcome~design_mat - 1, family=binomial(link='logit'), 	#
				id=1:n, std.err='san.se')#
	} else {#
		stop('Invalid outcome type!')#
	}#
	beta_init <- summary(init_mod)$coefficients[desired_coef,1]#
	se_init <- summary(init_mod)$coefficients[desired_coef,2]#
#
	# Bootstrapping#
	b_vec <- rep(NA, num_boots)#
	z_vec <- rep(NA, num_boots)#
	for (i in 1:num_boots)#
	{#
		# Get bootstrap samples#
		samp_index <- sample(1:n, size=n, replace=TRUE)#
		temp_Y <- outcome[samp_index]#
		temp_X <- design_mat[samp_index,]#
		# If n small, need to check and make sure we can do the fitting/d_mat nonsingular.#
		# This runs fast when n small so ok to use a little more computing power.#
		if (n <= 500)#
		{#
			svd_min <- svd(temp_X)$d[ncol(temp_X)]#
			if (svd_min < 10^(-4)) {next}#
		} #
		# Get the sandwich estimator fast#
		if (outcome_type == 'C') {#
			bread <- solve(crossprod(temp_X))#
			b_hat <- ( bread %*% crossprod(temp_X,temp_Y) )#
			fit_y <- temp_X %*% b_hat#
			resid_sq <- as.numeric( (temp_Y - fit_y)^2 )#
			meat <- crossprod(temp_X * resid_sq, temp_X)#
			b_k <- b_hat[desired_coef]#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )	#
		} else {#
			boot_mod <- tryCatch(speedglm::speedglm.wfit(y=temp_Y, X=temp_X, family=binomial()), #
				warning=function(w) w, error=function(e) e)#
			if (length(class(boot_mod)) > 1) {next}#
			fitted <- as.numeric( expit( temp_X %*% boot_mod$coefficients ) )#
			bread <- solve( crossprod(temp_X * fitted * (1-fitted), temp_X) )#
			meat <- crossprod(temp_X*(temp_Y-fitted)^2, temp_X)#
			s_k <- sqrt( (bread %*% meat %*% bread)[desired_coef,desired_coef] )#
			b_k <- boot_mod$coefficients[desired_coef]#
		}#
		b_vec[i] <- b_k#
		z_vec[i] <- ((b_k-beta_init)/s_k)^2#
	}#
	# Match moments#
	mean_Z <- mean(z_vec, na.rm=TRUE)#
	var_Z <- var(z_vec, na.rm=TRUE)#
	cee <- var_Z / (2*mean_Z)#
	a <- mean_Z / cee#
	# Calculate p-value#
	test_stat <- (beta_init / se_init)^2 / cee#
	p_value <- 1-pgamma(test_stat, shape=a/2, scale=2)
summary(init_mod)
p_value
runif(n=6, min=0, max=1)
as.list(runif(n=6, min=0, max=1))
as.list(rep(0.3,1))
as.list(rep(0.3,6))
library(devtools)
?ccheck
?check
R.version()
R.Version()
library(mvtnorm)
library(ggplot)
library(ggplot2)
